<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Core.Fluent-4.0</name></assembly>
<members>
<member name="M:FSharp.Core.Fluent.OptionExtensionsConstrained.toObj``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Convert an option to a potentially null value.</summary>
 <returns>The result value, which is null if the input was None.</returns>
</member>
<member name="M:FSharp.Core.Fluent.OptionExtensionsConstrained.toNullable``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Convert the option to a Nullable value.</summary>
 <returns>The result value.</returns>
</member>
<member name="T:FSharp.Core.Fluent.OptionExtensionsConstrained">
 <summary>Fluent extension operations on options which require constrained types.</summary>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensionsConstrained.unzip3``3(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1,``2}})">
 <summary>Splits an list of triples into three arrays.</summary>
 <param name="list">The input list.</param>
 <returns>The tuple of three arrays.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensionsConstrained.unzip``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
 <summary>Splits an list of pairs into two arrays.</summary>
 <param name="list">The input list.</param>
 <returns>The two arrays.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensionsConstrained.sumBy``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns the sum of the results generated by applying the function to each element of the list.</summary>
 <param name="projection">The function to transform the list elements into the type to be summed.</param>
 <param name="list">The input list.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensionsConstrained.sum``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the sum of the elements in the list.</summary>
 <param name="list">The input list.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensionsConstrained.sort``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Sorts the elements of an list, returning a new list. Elements are compared using Operators.compare. </summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="list">The input list.</param>
 <returns>The sorted list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensionsConstrained.minBy``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns the lowest of all elements of the list, compared via Operators.min on the function result.</summary>

 <remarks>Throws ArgumentException for empty arrays.</remarks>
 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <returns>The minimum element.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensionsConstrained.min``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the lowest of all elements of the list, compared via Operators.min.</summary>

 <remarks>Throws ArgumentException for empty arrays</remarks>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <returns>The minimum element.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensionsConstrained.maxBy``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns the greatest of all elements of the list, compared via Operators.max on the function result.</summary>

 <remarks>Throws ArgumentException for empty arrays.</remarks>
 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <returns>The maximum element.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensionsConstrained.max``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the greatest of all elements of the list, compared via Operators.max on the function result.</summary>

 <remarks>Throws ArgumentException for empty arrays.</remarks>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <returns>The maximum element.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensionsConstrained.distinct``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a list that contains no duplicate entries according to generic hash and
 equality comparisons on the entries.
 If an element occurs multiple times in the list then the later occurrences are discarded.</summary>

 <param name="list">The input list.</param>

 <returns>The result list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensionsConstrained.averageBy``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns the average of the elements generated by applying the function to each element of the list.</summary>
 <param name="projection">The function to transform the list elements before averaging.</param>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when <c>list</c> is empty.</exception>
 <returns>The computed average.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensionsConstrained.average``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the average of the elements in the list.</summary>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when <c>list</c> is empty.</exception>
 <returns>The average of the elements in the list.</returns>
</member>
<member name="T:FSharp.Core.Fluent.ListExtensionsConstrained">
 <summary>Fluent extension operations on lists which require constrained types.</summary>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.unzip3``3(System.Tuple{``0,``1,``2}[])">
 <summary>Splits an array of triples into three arrays.</summary>
 <param name="array">The input array.</param>
 <returns>The tuple of three arrays.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.unzip``2(System.Tuple{``0,``1}[])">
 <summary>Splits an array of pairs into two arrays.</summary>
 <param name="array">The input array.</param>
 <returns>The two arrays.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.sumBy``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns the sum of the results generated by applying the function to each element of the array.</summary>
 <param name="projection">The function to transform the array elements into the type to be summed.</param>
 <param name="array">The input array.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.sum``1(``0[])">
 <summary>Returns the sum of the elements in the array.</summary>
 <param name="array">The input array.</param>
 <returns>The resulting sum.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.sortInPlace``1(``0[])">
 <summary>Sorts the elements of an array by mutating the array in-place, using the given comparison function. 
 Elements are compared using Operators.compare.</summary>
 <param name="array">The input array.</param>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.sortDescending``1(``0[])">
 <summary>Sorts the elements of an array, in descending order, returning a new array. Elements are compared using Operators.compare. </summary>

 <param name="array">The input array.</param>
 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <returns>The sorted array.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.sort``1(``0[])">
 <summary>Sorts the elements of an array, returning a new array. Elements are compared using Operators.compare. </summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="array">The input array.</param>
 <returns>The sorted array.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.minBy``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns the lowest of all elements of the array, compared via Operators.min on the function result.</summary>

 <remarks>Throws ArgumentException for empty arrays.</remarks>
 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <returns>The minimum element.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.min``1(``0[])">
 <summary>Returns the lowest of all elements of the array, compared via Operators.min.</summary>

 <remarks>Throws ArgumentException for empty arrays</remarks>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <returns>The minimum element.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.maxBy``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns the greatest of all elements of the array, compared via Operators.max on the function result.</summary>

 <remarks>Throws ArgumentException for empty arrays.</remarks>
 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <returns>The maximum element.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.max``1(``0[])">
 <summary>Returns the greatest of all elements of the array, compared via Operators.max on the function result.</summary>

 <remarks>Throws ArgumentException for empty arrays.</remarks>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <returns>The maximum element.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.distinct``1(``0[])">
 <summary>Returns an array that contains no duplicate entries according to generic hash and
 equality comparisons on the entries.
 If an element occurs multiple times in the array then the later occurrences are discarded.</summary>

 <param name="array">The input array.</param>

 <returns>The result array.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.contains``1(``0[],``0)">
 <summary>Tests if the array contains the specified element.</summary>
 <param name="value">The value to locate in the input array.</param>
 <param name="array">The input array.</param>
 <returns>True if the input array contains the specified element; false otherwise.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.averageBy``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns the average of the elements generated by applying the function to each element of the array.</summary>
 <param name="projection">The function to transform the array elements before averaging.</param>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when <c>array</c> is empty.</exception>
 <returns>The computed average.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensionsConstrained.average``1(``0[])">
 <summary>Returns the average of the elements in the array.</summary>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentException">Thrown when <c>array</c> is empty.</exception>
 <returns>The average of the elements in the array.</returns>
</member>
<member name="T:FSharp.Core.Fluent.ArrayExtensionsConstrained">
 <summary>Fluent extension operations on arrays which require constrained types.</summary>
</member>
<member name="M:FSharp.Core.Fluent.NativePtrExtensions.nativeptr`1.set_Item``1(``0*,System.Int32,``0)">
 <summary>Gets or assigns the memory location referenced by the typed native 
 pointer computed by adding index * sizeof&lt;'T&gt; to the given input pointer.</summary>
 <param name="ptr">The input pointer.</param>
 <param name="index">The index by which to offset the pointer.</param>
</member>
<member name="M:FSharp.Core.Fluent.NativePtrExtensions.nativeptr`1.get_Item``1(``0*,System.Int32)">
 <summary>Gets or assigns the memory location referenced by the typed native 
 pointer computed by adding index * sizeof&lt;'T&gt; to the given input pointer.</summary>
 <param name="ptr">The input pointer.</param>
 <param name="index">The index by which to offset the pointer.</param>
</member>
<member name="M:FSharp.Core.Fluent.NativePtrExtensions.nativeptr`1.write``1(``0*,``0)">
 <summary>Assigns the <c>value</c> into the memory location referenced by the given typed native pointer.</summary>
 <param name="ptr">The input pointer.</param>
 <param name="value">The value to assign.</param>
</member>
<member name="M:FSharp.Core.Fluent.NativePtrExtensions.nativeptr`1.read``1(``0*)">
 <summary>Dereferences the given typed native pointer.</summary>
 <param name="ptr">The input pointer.</param>
 <returns>The value at the pointer address.</returns>
</member>
<member name="M:FSharp.Core.Fluent.NativePtrExtensions.nativeptr`1.add``1(``0*,System.Int32)">
 <summary>Returns a typed native pointer by adding index * sizeof&lt;'T&gt; to the 
 given input pointer.</summary>
 <param name="ptr">The input pointer.</param>
 <param name="index">The index by which to offset the pointer.</param>
 <returns>A typed pointer.</returns>
</member>
<member name="M:FSharp.Core.Fluent.NativePtrExtensions.nativeptr`1.toNativeInt``1(``0*)">
 <summary>Returns a machine address for a given typed native pointer.</summary>
 <param name="ptr">The input pointer.</param>
 <returns>The machine address.</returns>
</member>
<member name="T:FSharp.Core.Fluent.NativePtrExtensions">
 <summary>Fluent extension operations on native pointers.</summary>
</member>
<member name="M:FSharp.Core.Fluent.EventExtensions.IEvent`2.pairwise``2(Microsoft.FSharp.Control.IEvent{``0,``1})">
 <summary>Returns a new event that triggers on the second and subsequent triggerings of the input event.
 The Nth triggering of the input event passes the arguments from the N-1th and Nth triggering as
 a pair. The argument passed to the N-1th triggering is held in hidden internal state until the 
 Nth triggering occurs.</summary>
 <returns>An event that triggers on pairs of consecutive values passed from the source event.</returns>
</member>
<member name="M:FSharp.Core.Fluent.EventExtensions.IEvent`2.add``2(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit})">
 <summary>Runs the given function each time the given event is triggered.</summary>
 <param name="callback">The function to call when the event is triggered.</param>
 <param name="evt">The input event.</param>
</member>
<member name="M:FSharp.Core.Fluent.EventExtensions.IEvent`2.scan``3(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``2)">
 <summary>Returns a new event consisting of the results of applying the given accumulating function
 to successive values triggered on the input event.  An item of internal state
 records the current value of the state parameter.  The internal state is not locked during the
 execution of the accumulation function, so care should be taken that the 
 input IEvent not triggered by multiple threads simultaneously.</summary>
 <param name="collector">The function to update the state with each event value.</param>
 <param name="state">The initial state.</param>
 <returns>An event that fires on the updated state values.</returns>
</member>
<member name="M:FSharp.Core.Fluent.EventExtensions.IEvent`2.choose``3(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}})">
 <summary>Returns a new event which fires on a selection of messages from the original event.
 The selection function takes an original message to an optional new message.</summary>
 <param name="chooser">The function to select and transform event values to pass on.</param>
 <returns>An event that fires only when the chooser returns Some.</returns>
</member>
<member name="M:FSharp.Core.Fluent.EventExtensions.IEvent`2.split``4(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{``2,``3}})">
 <summary>Returns a new event that listens to the original event and triggers the 
 first resulting event if the application of the function to the event arguments
 returned a Choice1Of2, and the second event if it returns a Choice2Of2.</summary>
 <param name="splitter">The function to transform event values into one of two types.</param>
 <returns>A tuple of events.  The first fires whenever <c>splitter</c> evaluates to Choice1of1 and
 the second fires whenever <c>splitter</c> evaluates to Choice2of2.</returns>
</member>
<member name="M:FSharp.Core.Fluent.EventExtensions.IEvent`2.partition``2(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean})">
 <summary>Returns a new event that listens to the original event and triggers the 
 first resulting event if the application of the predicate to the event arguments
 returned true, and the second event if it returned false.</summary>
 <param name="predicate">The function to determine which output event to trigger.</param>
 <returns>A tuple of events.  The first is triggered when the predicate evaluates to true
 and the second when the predicate evaluates to false.</returns>
</member>
<member name="M:FSharp.Core.Fluent.EventExtensions.IEvent`2.filter``2(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean})">
 <summary>Returns a new event that listens to the original event and triggers the resulting
 event only when the argument to the event passes the given function.</summary>
 <param name="predicate">The function to determine which triggers from the event to propagate.</param>
 <returns>An event that only passes values that pass the predicate.</returns>
</member>
<member name="M:FSharp.Core.Fluent.EventExtensions.IEvent`2.map``3(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2})">
 <summary>Returns a new event that passes values transformed by the given function.</summary>
 <param name="map">The function to transform event values.</param>
 <returns>An event that passes the transformed values.</returns>
</member>
<member name="M:FSharp.Core.Fluent.EventExtensions.IEvent`2.merge``3(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Control.IEvent{``2,``1})">
 <summary>Fires the output event when either of the input events fire.</summary>
 <param name="evt">The first input event.</param>
 <param name="evt2">The second input event.</param>
 <returns>An event that fires when either of the input events fire.</returns>
</member>
<member name="T:FSharp.Core.Fluent.EventExtensions">
 <summary>Fluent extension operations on events.</summary>
</member>
<member name="M:FSharp.Core.Fluent.ObservableExtensions.IObservable`1.pairwise``1(System.IObservable{``0})">
 <summary>Returns a new observable that triggers on the second and subsequent triggerings of the input observable.
 The Nth triggering of the input observable passes the arguments from the N-1th and Nth triggering as
 a pair. The argument passed to the N-1th triggering is held in hidden internal state until the 
 Nth triggering occurs.</summary>

 <remarks>For each observer, the registered intermediate observing object is not thread safe.
 That is, observations arising from the source must not be triggered concurrently 
 on different threads.</remarks>
 <param name="obs">The input Observable.</param>
 <returns>An Observable that triggers on successive pairs of observations from the input Observable.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ObservableExtensions.IObservable`1.subscribe``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
 <summary>Creates an observer which subscribes to the given observable and which calls
 the given function for each observation.</summary>
 <param name="callback">The function to be called on each observation.</param>
 <param name="obs">The input Observable.</param>
 <returns>An object that will remove the callback if disposed.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ObservableExtensions.IObservable`1.add``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
 <summary>Creates an observer which permanently subscribes to the given observable and which calls
 the given function for each observation.</summary>
 <param name="callback">The function to be called on each observation.</param>
 <param name="obs">The input Observable.</param>
</member>
<member name="M:FSharp.Core.Fluent.ObservableExtensions.IObservable`1.scan``2(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1)">
 <summary>Returns an observable which, for each observer, allocates an item of state
 and applies the given accumulating function to successive values arising from
 the input. The returned object will trigger observations for each computed 
 state value, excluding the initial value. The returned object propagates 
 all errors arising from the source and completes when the source completes.</summary>

 <remarks>For each observer, the registered intermediate observing object is not thread safe.
 That is, observations arising from the source must not be triggered concurrently 
 on different threads.</remarks>
 <param name="collector">The function to update the state with each observation.</param>
 <param name="state">The initial state.</param>
 <param name="obs">The input Observable.</param>
 <returns>An Observable that triggers on the updated state values.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ObservableExtensions.IObservable`1.choose``2(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
 <summary>Returns an observable which chooses a projection of observations from the source 
 using the given function. The returned object will trigger observations <c>x</c>
 for which the splitter returns <c>Some x</c>. The returned object also propagates 
 all errors arising from the source and completes when the source completes.</summary>
 <param name="chooser">The function that returns Some for observations to be propagated
 and None for observations to ignore.</param>
 <param name="obs">The input Observable.</param>
 <returns>An Observable that only propagates some of the observations from the source.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ObservableExtensions.IObservable`1.split``3(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}})">
 <summary>Returns two observables which split the observations of the source by the 
 given function. The first will trigger observations <c>x</c> for which the 
 splitter returns <c>Choice1Of2 x</c>. The second will trigger observations 
 <c>y</c> for which the splitter returns <c>Choice2Of2 y</c> The splitter is 
 executed once for each subscribed observer. Both also propagate error 
 observations arising from the source and each completes when the source 
 completes.</summary>
 <param name="splitter">The function that takes an observation an transforms
 it into one of the two output Choice types.</param>
 <param name="obs">The input Observable.</param>
 <returns>A tuple of Observables.  The first triggers when <c>splitter</c> returns Choice1of2
 and the second triggers when <c>splitter</c> returns Choice2of2.</returns> 
</member>
<member name="M:FSharp.Core.Fluent.ObservableExtensions.IObservable`1.partition``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns two observables which partition the observations of the source by 
 the given function. The first will trigger observations for those values 
 for which the predicate returns true. The second will trigger observations 
 for those values where the predicate returns false. The predicate is 
 executed once for each subscribed observer. Both also propagate all error 
 observations arising from the source and each completes when the source 
 completes.</summary>
 <param name="predicate">The function to determine which output Observable will trigger
 a particular observation.</param>
 <param name="obs">The input Observable.</param>
 <returns>A tuple of Observables.  The first triggers when the predicate returns true, and
 the second triggers when the predicate returns false.</returns> 
</member>
<member name="M:FSharp.Core.Fluent.ObservableExtensions.IObservable`1.filter``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns an observable which filters the observations of the source 
 by the given function. The observable will see only those observations
 for which the predicate returns true. The predicate is executed once for 
 each subscribed observer. The returned object also propagates error 
 observations arising from the source and completes when the source completes.</summary>
 <param name="filter">The function to apply to observations to determine if it should
 be kept.</param>
 <param name="obs">The input Observable.</param>
 <returns>An Observable that filters observations based on <c>filter</c>.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ObservableExtensions.IObservable`1.map``2(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns an observable which transforms the observations of the source by the 
 given function. The transformation function is executed once for each 
 subscribed observer. The returned object also propagates error observations 
 arising from the source and completes when the source completes.</summary>
 <param name="mapping">The function applied to observations from the source.</param>
 <param name="source">The input Observable.</param>
 <returns>An Observable of the type specified by <c>mapping</c>.</returns> 
</member>
<member name="M:FSharp.Core.Fluent.ObservableExtensions.IObservable`1.merge``1(System.IObservable{``0},System.IObservable{``0})">
 <summary>Returns an observable for the merged observations from the sources. 
 The returned object propagates success and error values arising 
 from either source and completes when both the sources have completed.</summary>

 <remarks>For each observer, the registered intermediate observing object is not 
 thread safe. That is, observations arising from the sources must not 
 be triggered concurrently on different threads.</remarks>
 <param name="obs">The first Observable.</param>
 <param name="obs2">The second Observable.</param>
 <returns>An Observable that propagates information from both sources.</returns>
</member>
<member name="T:FSharp.Core.Fluent.ObservableExtensions">
 <summary>Fluent extension operations on observables.</summary>
</member>
<member name="M:FSharp.Core.Fluent.NullableExtensions.Nullable`1.toOption``1(System.Nullable{``0})">
 <summary>Convert a Nullable value to an option.</summary>
 <returns>The result option.</returns>
</member>
<member name="T:FSharp.Core.Fluent.NullableExtensions">
 <summary>Fluent extension operations on options.</summary>
</member>
<member name="M:FSharp.Core.Fluent.OptionExtensions.Option`1.filter``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary><c>filter f inp</c> evaluates to <c>match inp with None -> None | Some x -> if f x then Some x else None</c>.</summary>
 <param name="predicate">A function that evaluates whether the value contained in the option should remain, or be filtered out.</param>
 <returns>The input if the predicate evaluates to true; otherwise, None.</returns>
</member>
<member name="M:FSharp.Core.Fluent.OptionExtensions.Option`1.toList``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Convert the option to a list of length 0 or 1.</summary>
 <returns>The result list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.OptionExtensions.Option`1.toArray``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Convert the option to an array of length 0 or 1.</summary>
 <returns>The result array.</returns>
</member>
<member name="M:FSharp.Core.Fluent.OptionExtensions.Option`1.bind``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
 <summary><c>bind f inp</c> evaluates to <c>match inp with None -> None | Some x -> f x</c></summary>
 <param name="binder">A function that takes the value of type T from an option and transforms it into
 an option containing a value of type U.</param>
 <returns>An option of the output type of the binder.</returns>
</member>
<member name="M:FSharp.Core.Fluent.OptionExtensions.Option`1.map``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary><c>map f inp</c> evaluates to <c>match inp with None -> None | Some x -> Some (f x)</c>.</summary>
 <param name="mapping">A function to apply to the option value.</param>
 <returns>An option of the input value after applying the mapping function, or None if the input is None.</returns>
</member>
<member name="M:FSharp.Core.Fluent.OptionExtensions.Option`1.iter``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
 <summary><c>iter f inp</c> executes <c>match inp with None -> () | Some x -> f x</c>.</summary>
 <param name="action">A function to apply to the option value.</param>
 <returns>Unit if the option is None, otherwise it returns the result of applying the predicate
 to the option value.</returns>
</member>
<member name="M:FSharp.Core.Fluent.OptionExtensions.Option`1.forall``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary><c>forall p inp</c> evaluates to <c>match inp with None -> true | Some x -> p x</c>.</summary>
 <param name="predicate">A function that evaluates to a boolean when given a value from the option type.</param>
 <returns>True if the option is None, otherwise it returns the result of applying the predicate
 to the option value.</returns>
</member>
<member name="M:FSharp.Core.Fluent.OptionExtensions.Option`1.exists``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary><c>exists p inp</c> evaluates to <c>match inp with None -> false | Some x -> p x</c>.</summary>
 <param name="predicate">A function that evaluates to a boolean when given a value from the option type.</param>
 <returns>False if the option is None, otherwise it returns the result of applying the predicate
 to the option value.</returns>
</member>
<member name="M:FSharp.Core.Fluent.OptionExtensions.Option`1.foldBack``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1)">
 <summary><c>fold f inp s</c> evaluates to <c>match inp with None -> s | Some x -> f x s</c>.</summary>
 <param name="folder">A function to update the state data when given a value from an option.</param>
 <param name="state">The initial state.</param>
 <returns>The original state if the option is None, otherwise it returns the updated state with the folder
 and the option value.</returns>
</member>
<member name="M:FSharp.Core.Fluent.OptionExtensions.Option`1.fold``2(Microsoft.FSharp.Core.FSharpOption{``0},``1,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
 <summary><c>fold f s inp</c> evaluates to <c>match inp with None -> s | Some x -> f s x</c>.</summary>
 <param name="folder">A function to update the state data when given a value from an option.</param>
 <param name="state">The initial state.</param>
 <returns>The original state if the option is None, otherwise it returns the updated state with the folder
 and the option value.</returns>
</member>
<member name="M:FSharp.Core.Fluent.OptionExtensions.Option`1.get_count``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Evaluates to <c>match inp with None -> 0 | Some _ -> 1</c>.</summary>
 <returns>A zero if the option is None, a one otherwise.</returns>
</member>
<member name="T:FSharp.Core.Fluent.OptionExtensions">
 <summary>Fluent extension operations on options.</summary>
</member>
<member name="M:FSharp.Core.Fluent.StringExtensions.String.get_length(System.String)">
 <summary>Returns the length of the string.</summary>
 <returns>The number of characters in the string.</returns>
</member>
<member name="M:FSharp.Core.Fluent.StringExtensions.String.replicate(System.String,System.Int32)">
 <summary>Returns a string by concatenating <c>count</c> instances of <c>str</c>.</summary>
 <param name="count">The number of copies of the input string will be copied.</param>
 <returns>The concatenated string.</returns>
 <exception cref="System.ArgumentException">Thrown when <c>count</c> is negative.</exception>
</member>
<member name="M:FSharp.Core.Fluent.StringExtensions.String.exists(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
 <summary>Tests if any character of the string satisfies the given predicate.</summary>
 <param name="predicate">The function to test each character of the string.</param>
 <returns>True if any character returns true for the predicate and false otherwise.</returns>
</member>
<member name="M:FSharp.Core.Fluent.StringExtensions.String.forall(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
 <summary>Tests if all characters in the string satisfy the given predicate.</summary>
 <param name="predicate">The function to test each character of the string.</param>
 <returns>True if all characters return true for the predicate and false otherwise.</returns>
</member>
<member name="M:FSharp.Core.Fluent.StringExtensions.String.collect(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.String})">
 <summary>Builds a new string whose characters are the results of applying the function <c>mapping</c>
 to each of the characters of the input string and concatenating the resulting
 strings.</summary>
 <param name="mapping">The function to produce a string from each character of the input string.</param>
 <returns>The concatenated string.</returns>
</member>
<member name="M:FSharp.Core.Fluent.StringExtensions.String.mapi(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Char}})">
 <summary>Builds a new string whose characters are the results of applying the function <c>mapping</c>
 to each character and index of the input string.</summary>
 <param name="mapping">The function to apply to each character and index of the string.</param>
 <returns>The resulting string.</returns>
</member>
<member name="M:FSharp.Core.Fluent.StringExtensions.String.map(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Char})">
 <summary>Builds a new string whose characters are the results of applying the function <c>mapping</c>
 to each of the characters of the input string.</summary>
 <param name="mapping">The function to apply to the characters of the string.</param>
 <returns>The resulting string.</returns>
</member>
<member name="M:FSharp.Core.Fluent.StringExtensions.String.iteri(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit}})">
 <summary>Applies the function <c>action</c> to the index of each character in the string and the
 character itself.</summary>
 <param name="action">The function to apply to each character and index of the string.</param>
</member>
<member name="M:FSharp.Core.Fluent.StringExtensions.String.iter(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit})">
 <summary>Applies the function <c>action</c> to each character in the string.</summary>
 <param name="action">The function to be applied to each character of the string.</param>
</member>
<member name="T:FSharp.Core.Fluent.StringExtensions">
 <summary>Fluent extension operations on strings.</summary>
</member>
<member name="M:FSharp.Core.Fluent.Array4DExtensions.[,,,]`1.get_length4``1(``0[0:,0:,0:,0:])">
 <summary>Returns the length of an array in the fourth dimension.</summary>
 <returns>The length of the array in the fourth dimension.</returns>
</member>
<member name="M:FSharp.Core.Fluent.Array4DExtensions.[,,,]`1.get_length3``1(``0[0:,0:,0:,0:])">
 <summary>Returns the length of an array in the third dimension.</summary>
 <returns>The length of the array in the third dimension.</returns>
</member>
<member name="M:FSharp.Core.Fluent.Array4DExtensions.[,,,]`1.get_length2``1(``0[0:,0:,0:,0:])">
 <summary>Returns the length of an array in the second dimension.</summary>
 <returns>The length of the array in the second dimension.</returns>
</member>
<member name="M:FSharp.Core.Fluent.Array4DExtensions.[,,,]`1.get_length1``1(``0[0:,0:,0:,0:])">
 <summary>Returns the length of an array in the first dimension  </summary>
 <returns>The length of the array in the first dimension.</returns>
</member>
<member name="T:FSharp.Core.Fluent.Array4DExtensions">
 <summary>Fluent extension operations on 4D arrays.</summary>
</member>
<member name="M:FSharp.Core.Fluent.Array3DExtensions.[,,]`1.mapi``2(``0[0:,0:,0:],Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}}}})">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer indices passed to the
 function indicates the element being transformed.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propogated to the output
 array.</remarks>
 <param name="mapping">The function to transform the elements at each index in the array.</param>
 <returns>The array created from the transformed elements.</returns>
</member>
<member name="M:FSharp.Core.Fluent.Array3DExtensions.[,,]`1.map``2(``0[0:,0:,0:],Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propogated to the output
 array.</remarks>
 <param name="mapping">The function to transform each element of the array.</param>
 <returns>The array created from the transformed elements.</returns>
</member>
<member name="M:FSharp.Core.Fluent.Array3DExtensions.[,,]`1.get_length3``1(``0[0:,0:,0:])">
 <summary>Returns the length of an array in the third dimension.</summary>
 <returns>The length of the array in the third dimension.</returns>
</member>
<member name="M:FSharp.Core.Fluent.Array3DExtensions.[,,]`1.get_length2``1(``0[0:,0:,0:])">
 <summary>Returns the length of an array in the second dimension.</summary>
 <returns>The length of the array in the second dimension.</returns>
</member>
<member name="M:FSharp.Core.Fluent.Array3DExtensions.[,,]`1.get_length1``1(``0[0:,0:,0:])">
 <summary>Returns the length of an array in the first dimension  </summary>
 <returns>The length of the array in the first dimension.</returns>
</member>
<member name="M:FSharp.Core.Fluent.Array3DExtensions.[,,]`1.iteri``1(``0[0:,0:,0:],Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}}})">
 <summary>Applies the given function to each element of the array. The integer indicies passed to the
 function indicates the index of element.</summary>
 <param name="action">The function to apply to each element of the array.</param>
</member>
<member name="M:FSharp.Core.Fluent.Array3DExtensions.[,,]`1.iter``1(``0[0:,0:,0:],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
 <summary>Applies the given function to each element of the array.</summary>
 <param name="action">The function to apply to each element of the array.</param>
 <param name="array">The input array.</param>
</member>
<member name="T:FSharp.Core.Fluent.Array3DExtensions">
 <summary>Fluent extension operations on 3D arrays.</summary>
</member>
<member name="M:FSharp.Core.Fluent.Array2DExtensions.[,]`1.copy``1(``0[0:,0:])">
 <summary>Builds a new array whose elements are the same as the input array.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propogated to the output
 array.</remarks>

 <returns>A copy of the input array.</returns>
</member>
<member name="M:FSharp.Core.Fluent.Array2DExtensions.[,]`1.iteri``1(``0[0:,0:],Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}})">
 <summary>Applies the given function to each element of the array.  The integer indices passed to the
 function indicates the index of element.</summary>

 <param name="action">A function to apply to each element of the array with the indices available as an argument.</param>
</member>
<member name="M:FSharp.Core.Fluent.Array2DExtensions.[,]`1.iter``1(``0[0:,0:],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
 <summary>Applies the given function to each element of the array.</summary>

 <param name="action">A function to apply to each element of the array.</param>
</member>
<member name="M:FSharp.Core.Fluent.Array2DExtensions.[,]`1.mapi``2(``0[0:,0:],Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}}})">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer indices passed to the
 function indicates the element being transformed.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propagated to the output
 array.</remarks>

 <param name="mapping">A function that is applied to transform each element of the array.  The two integers
 provide the index of the element.</param>

 <returns>An array whose elements have been transformed by the given mapping.</returns>
</member>
<member name="M:FSharp.Core.Fluent.Array2DExtensions.[,]`1.map``2(``0[0:,0:],Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propogated to the output
 array.</remarks>

 <param name="mapping">A function that is applied to transform each item of the input array.</param>

 <returns>An array whose elements have been transformed by the given mapping.</returns>
</member>
<member name="M:FSharp.Core.Fluent.Array2DExtensions.[,]`1.rebase``1(``0[0:,0:])">
 <summary>Builds a new array whose elements are the same as the input array but
 where a non-zero-based input array generates a corresponding zero-based 
 output array.</summary>

 <returns>The zero-based output array.</returns>
</member>
<member name="M:FSharp.Core.Fluent.Array2DExtensions.[,]`1.get_length2``1(``0[0:,0:])">
 <summary>Returns the length of an array in the second dimension.</summary>

 <returns>The length of the array in the second dimension.</returns>  
</member>
<member name="M:FSharp.Core.Fluent.Array2DExtensions.[,]`1.get_length1``1(``0[0:,0:])">
 <summary>Returns the length of an array in the first dimension.</summary>

 <returns>The length of the array in the first dimension.</returns>  
</member>
<member name="M:FSharp.Core.Fluent.Array2DExtensions.[,]`1.get_base2``1(``0[0:,0:])">
 <summary>Fetches the base-index for the second dimension of the array.</summary>

 <returns>The base-index of the second dimension of the array.</returns>
</member>
<member name="M:FSharp.Core.Fluent.Array2DExtensions.[,]`1.get_base1``1(``0[0:,0:])">
 <summary>Fetches the base-index for the first dimension of the array.</summary>

 <returns>The base-index of the first dimension of the array.</returns>
</member>
<member name="T:FSharp.Core.Fluent.Array2DExtensions">
 <summary>Fluent extension operations on 2D arrays.</summary>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.tryHead``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the first element of the list, or
 <c>None</c> if the list is empty.</summary>
 <returns>The first element of the list or None.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.tryLast``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the last element of the list.
 Return <c>None</c> if no such element exists.</summary>
 <returns>The last element of the list or None.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.last``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the last element of the list.</summary>
 <returns>The last element of the list.</returns>
 <exception cref="System.ArgumentException">Thrown when the input does not have any elements.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.head``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the first element of the list.</summary>

 <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
 <returns>The first element of the list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.tail``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the list after removing the first element.</summary>

 <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
 <returns>The list after removing the first element.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.tryItem``1(Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
 <summary>Tries to find the nth element in the list.
 Returns <c>None</c> if index is negative or the list does not contain enough elements.</summary>
 <param name="index">The index to retrieve.</param>
 <returns>The value at the given index or <c>None</c>.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.tryFindBack``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the last element for which the given function returns <c>true.</c>.
 Return <c>None</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <returns>The last element for which the predicate returns true, or None if
 every element evaluates to false.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.tryFindIndexBack``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the index of the last element in the list
 that satisfies the given predicate.
 Return <c>None</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <returns>The index of the last element for which the predicate returns true, or None if
 every element evaluates to false.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.sortByDescending``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Sorts the given list in descending order using keys given by the given projection. Keys are compared using Operators.compare.</summary>

 <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
 <param name="projection">The function to transform the list elements into the type to be compared.</param>
 <returns>The sorted list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.exactlyOne``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the only element of the list.</summary>

 <returns>The only element of the list.</returns>
        
 <exception cref="System.ArgumentException">Thrown when the input does not have precisely one element.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.indexed``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a list of sliding windows containing elements drawn from the input
 list. Each window is returned as a fresh list.</summary>
 <param name="windowSize">The number of elements in each window.</param>
 <returns>The result list.</returns>
 <exception cref="System.ArgumentException">Thrown when windowSize is not positive.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.windowed``1(Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
 <summary>Returns a list of sliding windows containing elements drawn from the input
 list. Each window is returned as a fresh list.</summary>
 <param name="windowSize">The number of elements in each window.</param>
 <param name="list">The input list.</param>
 <returns>The result list.</returns>
 <exception cref="System.ArgumentException">Thrown when windowSize is not positive.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.where``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns a new list containing only the elements of the list
 for which the given predicate returns "true"</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <returns>A list containing only the elements that satisfy the predicate.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.truncate``1(Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
 <summary>Returns at most N elements in a new list.</summary>
 <param name="count">The maximum number of items to return.</param>
 <returns>The result list.</returns>
 <exception cref="System.ArgumentException">Thrown when the count is negative.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.takeWhile``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns a list that contains all elements of the original list while the 
 given predicate returns <c>true</c>, and then returns no further elements.</summary>

 <param name="predicate">A function that evaluates to false when no more items should be returned.</param>

 <returns>The result list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.take``1(Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
 <summary>Returns the first N elements of the list.</summary>
 <remarks>Throws <c>InvalidOperationException</c>
 if the count exceeds the number of elements in the list. <c>List.truncate</c>
 returns as many items as the list contains instead of throwing an exception.</remarks>

 <param name="count">The number of items to take.</param>

 <returns>The result list.</returns>

 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the list.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.skipWhile``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Bypasses elements in a list while the given predicate returns <c>true</c>, and then returns
 the remaining elements of the list.</summary>
 <param name="predicate">A function that evaluates an element of the list to a boolean value.</param>
 <returns>The result list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.skip``1(Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
 <summary>Returns the list after removing the first N elements.</summary>
 <param name="count">The number of elements to skip.</param>
 <returns>The list after removing the first N elements.</returns>
 <exception cref="System.ArgumentException">Thrown when count is negative or exceeds the number of 
 elements in the list.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.pairwise``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a list of each element in the input list and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.</summary>

 <returns>The result list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.groupBy``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Applies a key-generating function to each element of a list and yields a list of 
 unique keys. Each unique key contains a list of all elements that match 
 to this key.</summary>

 <param name="projection">A function that transforms an element of the list into a comparable key.</param>

 <returns>The result list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.distinctBy``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns a list that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the list then the later occurrences are discarded.</summary>

 <param name="projection">A function transforming the list items into comparable keys.</param>

 <returns>The result list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.countBy``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Applies a key-generating function to each element of a list and returns a list yielding unique
 keys and their number of occurrences in the original list.</summary>

 <param name="projection">A function transforming each item of the input list into a key to be
 compared against the others.</param>

 <returns>The result list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.zip3``3(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})">
 <summary>Combines three lists into an list of pairs. The three lists must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="list2">The second input list.</param>
 <param name="list3">The third input list.</param>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
 <returns>The list of tupled elements.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.zip``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Combines the two lists into an list of pairs. The two lists must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="list2">The second input list.</param>
 <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
 <returns>The list of tupled elements.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.tryFindIndex``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the index of the first element in the list
 that satisfies the given predicate.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <returns>The index of the first element that satisfies the predicate, or None.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.tryFind``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the first element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <returns>The first element that satisfies the predicate, or None.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.toSeq``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Views the given list as a sequence.</summary>
 <param name="list">The input list.</param>
 <returns>The sequence of list elements.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.sortWith``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}})">
 <summary>Sorts the elements of an list, using the given comparison function as the order, returning a new list.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="comparer">The function to compare pairs of list elements.</param>
 <param name="list">The input list.</param>
 <returns>The sorted list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.sortBy``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Sorts the elements of an list, using the given projection for the keys and returning a new list. 
 Elements are compared using Operators.compare.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="projection">The function to transform list elements into the type that is compared.</param>
 <param name="list">The input list.</param>
 <returns>The sorted list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.scanBack``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1)">
 <summary>Like <c>foldBack</c>, but return both the intermediary and final results.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="list">The input list.</param>
 <param name="state">The initial state.</param>
 <returns>The list of state values.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.scan``2(Microsoft.FSharp.Collections.FSharpList{``0},``1,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
 <summary>Like <c>fold</c>, but return the intermediary and final results.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="list">The input list.</param>
 <returns>The list of state values.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.reverse``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a new list with the elements in reverse order.</summary>
 <param name="list">The input list.</param>
 <returns>The reversed list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.reduceBack``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
 <summary>Applies a function to each element of the list, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f i0 (...(f iN-1 iN))</c>.
 Raises ArgumentException if the list has size zero.</summary>
 <param name="reduction">The function to reduce a pair of elements to a single element.</param>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <returns>The final result of the reductions.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.reduce``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
 <summary>Applies a function to each element of the list, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f i0 i1)...) iN</c>.
 Raises ArgumentException if the list has size zero.</summary>
 <param name="reduction">The function to reduce a pair of elements to a single element.</param>
 <param name="list">The input list.</param>
 <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
 <returns>The final result of the redcutions.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.permute``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32})">
 <summary>Returns an list with all elements permuted according to the
 specified permutation.</summary>
 <param name="indexMap">The function that maps input indices to output indices.</param>
 <param name="list">The input list.</param>
 <returns>The output list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.partition``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Splits the collection into two collections, containing the 
 elements for which the given predicate returns "true" and "false"
 respectively.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <returns>A pair of lists. The first containing the elements the predicate evaluated to true,
 and the second containing those evaluated to false.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.mapi``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
 <summary>Builds a new list whose elements are the results of applying the given function
 to each of the elements of the list. The integer index passed to the
 function indicates the index of element being transformed.</summary>
 <param name="mapping">The function to transform elements and their indices.</param>
 <param name="list">The input list.</param>
 <returns>The list of transformed elements.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.map``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Builds a new list whose elements are the results of applying the given function
 to each of the elements of the list.</summary>
 <param name="mapping">The function to transform elements of the list.</param>
 <param name="list">The input list.</param>
 <returns>The list of transformed elements.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.get_length``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the length of an list. You can also use property arr.Length.</summary>
 <param name="list">The input list.</param>
 <returns>The length of the list.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.iteri``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}})">
 <summary>Applies the given function to each element of the list. The integer passed to the
 function indicates the index of element.</summary>
 <param name="action">The function to apply to each index and element.</param>
 <param name="list">The input list.</param>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.iter``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
 <summary>Applies the given function to each element of the list.</summary>
 <param name="action">The function to apply.</param>
 <param name="list">The input list.</param>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.foldBack``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1)">
 <summary>Applies a function to each element of the list, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN s))</c></summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="list">The input list.</param>
 <param name="state">The initial state.</param>
 <returns>The final state.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.fold``2(Microsoft.FSharp.Collections.FSharpList{``0},``1,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f s i0)...) iN</c></summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="list">The input list.</param>
 <returns>The final state.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.forall``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Tests if all elements of the list satisfy the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input collection. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <returns>True if all of the list elements satisfy the predicate.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.findIndex``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the index of the first element in the list
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if 
 none of the elements satisy the predicate.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
 <returns>The index of the first element in the list that satisfies the given predicate.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.find``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the first element for which the given function returns 'true'.
 Raise <c>KeyNotFoundException</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
 <returns>The first element for which <c>predicate</c> returns true.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.filter``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true".</summary>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <returns>An list containing the elements for which the given predicate returns true.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.exists``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Tests if any element of the list satisfies the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input list. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>
 <returns>True if any result from <c>predicate</c> is true.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.choose``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
 <summary>Applies the given function to each element of the list. Returns
 the list comprised of the results "x" for each element where
 the function returns Some(x)</summary>
 <param name="chooser">The function to generate options from the elements.</param>
 <param name="list">The input list.</param>
 <returns>The list of results.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.pick``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
 <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>KeyNotFoundException</c> is raised.</summary>
 <param name="chooser">The function to generate options from the elements.</param>
 <param name="list">The input list.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if every result from
 <c>chooser</c> is <c>None</c>.</exception>
 <returns>The first result.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.tryPick``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
 <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>None</c> is returned.</summary>
 <param name="chooser">The function to transform the list elements into options.</param>
 <param name="list">The input list.</param>
 <returns>The first transformed element that is <c>Some(x)</c>.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.concat``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0}[])">
 <summary>Builds a new list that contains the elements of each of the given sequence of  lists.</summary>
 <param name=" lists">The input sequence of  lists.</param>
 <returns>The concatenation of the sequence of input  lists.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.collect``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Collections.FSharpList{``1}})">
 <summary>For each element of the list, applies the given function. Concatenates all the results and return the combined list.</summary>
 <param name="mapping">The function to create sub- lists from the input list elements.</param>
 <param name="list">The input list.</param>
 <returns>The concatenation of the sub- lists.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ListExtensions.List`1.append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds a new list that contains the elements of the first list followed by the elements of the second list.</summary>
 <param name=" list1">The first input list.</param>
 <param name=" list2">The second input list.</param>
 <returns>The resulting list.</returns>
</member>
<member name="T:FSharp.Core.Fluent.ListExtensions">
 <summary>Fluent extension operations on lists.</summary>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.tryHead``1(``0[])">
 <summary>Returns the first element of the array, or
 <c>None</c> if the array is empty.</summary>
 <param name="array">The input array.</param>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
 <returns>The first element of the array or None.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.tryLast``1(``0[])">
 <summary>Returns the last element of the array.
 Return <c>None</c> if no such element exists.</summary>
 <returns>The last element of the array or None.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception> 
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.last``1(``0[])">
 <summary>Returns the last element of the array.</summary>
 <returns>The last element of the array.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input does not have any elements.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.head``1(``0[])">
 <summary>Returns the first element of the array.</summary>

 <returns>The first element of the array.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.tail``1(``0[])">
 <summary>Returns a new array containing the elements of the original except the first element.</summary>

 <exception cref="System.ArgumentException">Thrown when the array is empty.</exception>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
 <returns>A new array containing the elements of the original except the first element.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.tryItem``1(``0[],System.Int32)">
 <summary>Tries to find the nth element in the array.
 Returns <c>None</c> if index is negative or the input array does not contain enough elements.</summary>
 <param name="index">The index of element to retrieve.</param>
 <returns>The nth element of the array or <c>None</c>.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.tryFindBack``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the last element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
 <returns>The last element that satisfies the predicate, or None.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.tryFindIndexBack``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the index of the last element in the array
 that satisfies the given predicate.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
 <returns>The index of the last element that satisfies the predicate, or None.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.sortByDescending``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Sorts the elements of an array, in descending order, using the given projection for the keys and returning a new array. 
 Elements are compared using Operators.compare.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="projection">The function to transform array elements into the type that is compared.</param>
 <returns>The sorted array.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.exactlyOne``1(``0[])">
 <summary>Returns the only element of the array.</summary>

 <returns>The only element of the array.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input does not have precisely one element.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.zip3``3(``0[],``1[],``2[])">
 <summary>Combines three arrays into an list of pairs. The three arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="array2">The second input list.</param>
 <param name="array3">The third input list.</param>
 <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
 <returns>The list of tupled elements.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.zip``2(``0[],``1[])">
 <summary>Combines the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
 <param name="array2">The second input array.</param>
 <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
 <returns>The array of tupled elements.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.tryFindIndex``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the index of the first element in the array
 that satisfies the given predicate.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <returns>The index of the first element that satisfies the predicate, or None.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.tryFind``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the first element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <returns>The first element that satisfies the predicate, or None.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.toSeq``1(``0[])">
 <summary>Views the given array as a sequence.</summary>
 <returns>The sequence of array elements.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.toList``1(``0[])">
 <summary>Builds a list from the given array.</summary>
 <returns>The list of array elements.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.sortInPlaceWith``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}})">
 <summary>Sorts the elements of an array by mutating the array in-place, using the given comparison function as the order.</summary>
 <param name="comparer">The function to compare pairs of array elements.</param>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.sortInPlaceBy``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Sorts the elements of an array by mutating the array in-place, using the given projection for the keys. 
 Elements are compared using Operators.compare.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="projection">The function to transform array elements into the type that is compared.</param>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.sortWith``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}})">
 <summary>Sorts the elements of an array, using the given comparison function as the order, returning a new array.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="comparer">The function to compare pairs of array elements.</param>
 <returns>The sorted array.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.sortBy``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Sorts the elements of an array, using the given projection for the keys and returning a new array. 
 Elements are compared using Operators.compare.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
 <param name="projection">The function to transform array elements into the type that is compared.</param>
 <returns>The sorted array.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.scanBack``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1)">
 <summary>Like <c>foldBack</c>, but return both the intermediary and final results.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <returns>The array of state values.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.scan``2(``0[],``1,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
 <summary>Like <c>fold</c>, but return the intermediary and final results.</summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <returns>The array of state values.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.reverse``1(``0[])">
 <summary>Returns a new array with the elements in reverse order.</summary>
 <returns>The reversed array.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.reduceBack``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
 <summary>Applies a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f i0 (...(f iN-1 iN))</c>.
 Raises ArgumentException if the array has size zero.</summary>
 <param name="reduction">The function to reduce a pair of elements to a single element.</param>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <returns>The final result of the reductions.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.reduce``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
 <summary>Applies a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f i0 i1)...) iN</c>.
 Raises ArgumentException if the array has size zero.</summary>
 <param name="reduction">The function to reduce a pair of elements to a single element.</param>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <returns>The final result of the redcutions.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.permute``1(``0[],Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32})">
 <summary>Returns an array with all elements permuted according to the
 specified permutation.</summary>
 <param name="indexMap">The function that maps input indices to output indices.</param>
 <returns>The output array.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="System.ArgumentException">Thrown when indexMap does not produce a valid permutation.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.partition``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Splits the collection into two collections, containing the 
 elements for which the given predicate returns "true" and "false"
 respectively.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <returns>A pair of arrays. The first containing the elements the predicate evaluated to true,
 and the second containing those evaluated to false.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.mapi``2(``0[],Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer index passed to the
 function indicates the index of element being transformed.</summary>
 <param name="mapping">The function to transform elements and their indices.</param>
 <returns>The array of transformed elements.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.map``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array.</summary>
 <param name="mapping">The function to transform elements of the array.</param>
 <returns>The array of transformed elements.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.get_length``1(``0[])">
 <summary>Returns the length of an array. You can also use property arr.Length.</summary>
 <returns>The length of the array.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.iteri``1(``0[],Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}})">
 <summary>Applies the given function to each element of the array. The integer passed to the
 function indicates the index of element.</summary>
 <param name="action">The function to apply to each index and element.</param>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.iter``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
 <summary>Applies the given function to each element of the array.</summary>
 <param name="action">The function to apply.</param>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.get_IsEmpty``1(``0[])">
 <summary>Returns true if the given array is empty, otherwise false.</summary>
 <returns>True if the array is empty.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.foldBack``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1)">
 <summary>Applies a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN s))</c></summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <returns>The final state.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.fold``2(``0[],``1,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f s i0)...) iN</c></summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <returns>The final state.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.forall``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Tests if all elements of the array satisfy the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input collection. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <returns>True if all of the array elements satisfy the predicate.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.findIndex``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the index of the first element in the array
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if 
 none of the elements satisy the predicate.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
 <returns>The index of the first element in the array that satisfies the given predicate.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.find``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the first element for which the given function returns 'true'.
 Raise <c>KeyNotFoundException</c> if no such element exists.</summary>
 <param name="predicate">The function to test the input elements.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
 <returns>The first element for which <c>predicate</c> returns true.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.filter``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true".</summary>
 <param name="predicate">The function to test the input elements.</param>
 <returns>An array containing the elements for which the given predicate returns true.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.exists``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Tests if any element of the array satisfies the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input array. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <returns>True if any result from <c>predicate</c> is true.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.indexed``1(``0[])">
 <summary>Builds a new array whose elements are the corresponding elements of the input array
 paired with the integer index (from 0) of each element.</summary>
 <returns>The array of indexed elements.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.windowed``1(``0[],System.Int32)">
 <summary>Returns an array of sliding windows containing elements drawn from the input
 array. Each window is returned as a fresh array.</summary>
 <param name="windowSize">The number of elements in each window.</param>
 <returns>The result array.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="System.ArgumentException">Thrown when windowSize is not positive.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.where``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns a new array containing only the elements of the array
 for which the given predicate returns "true".</summary>
 <param name="predicate">The function to test the input elements.</param>
 <returns>An array containing the elements for which the given predicate returns true.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.truncate``1(``0[],System.Int32)">
 <summary>Returns at most N elements in a new array.</summary>
 <param name="count">The maximum number of items to return.</param>
 <returns>The result array.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the count is negative.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.takeWhile``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns an array that contains all elements of the original array while the 
 given predicate returns <c>true</c>, and then returns no further elements.</summary>

 <param name="predicate">A function that evaluates to false when no more items should be returned.</param>

 <returns>The result array.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.take``1(``0[],System.Int32)">
 <summary>Returns the first N elements of the array.</summary>
 <remarks>Throws <c>InvalidOperationException</c>
 if the count exceeds the number of elements in the array. <c>Array.truncate</c>
 returns as many items as the array contains instead of throwing an exception.</remarks>

 <param name="count">The number of items to take.</param>

 <returns>The result array.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
 <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the list.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.skipWhile``1(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Bypasses elements in an array while the given predicate returns <c>true</c>, and then returns
 the remaining elements in a new array.</summary>
 <param name="predicate">A function that evaluates an element of the array to a boolean value.</param>
 <param name="source">The input array.</param>
 <returns>The created sub array.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.skip``1(``0[],System.Int32)">
 <summary>Builds a new array that contains the elements of the given array, excluding the first N elements.</summary>
 <param name="count">The number of elements to skip.</param>
 <returns>A copy of the input array, after removing the first N elements.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="System.ArgumentExcepion">Thrown when count is negative or exceeds the number of 
 elements in the array.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.pairwise``1(``0[])">
 <summary>Returns an array of each element in the input array and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.</summary>

 <returns>The result array.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.groupBy``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Applies a key-generating function to each element of an array and yields an array of 
 unique keys. Each unique key contains an array of all elements that match 
 to this key.</summary>

 <param name="projection">A function that transforms an element of the array into a comparable key.</param>

 <returns>The result array.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.distinctBy``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns an array that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the array then the later occurrences are discarded.</summary>

 <param name="projection">A function transforming the array items into comparable keys.</param>

 <returns>The result array.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.countBy``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Applies a key-generating function to each element of an array and returns an array yielding unique
 keys and their number of occurrences in the original array.</summary>

 <param name="projection">A function transforming each item of the input array into a key to be
 compared against the others.</param>
 <param name="array">The input array.</param>

 <returns>The result array.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.choose``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
 <summary>Applies the given function to each element of the array. Returns
 the array comprised of the results "x" for each element where
 the function returns Some(x)</summary>
 <param name="chooser">The function to generate options from the elements.</param>
 <returns>The array of results.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.pick``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
 <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>KeyNotFoundException</c> is raised.</summary>
 <param name="chooser">The function to generate options from the elements.</param>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if every result from
 <c>chooser</c> is <c>None</c>.</exception>
 <returns>The first result.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.tryPick``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
 <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>None</c> is returned.</summary>
 <param name="chooser">The function to transform the array elements into options.</param>
 <returns>The first transformed element that is <c>Some(x)</c>.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.copy``1(``0[])">
 <summary>Builds a new array that contains the elements of the given array.</summary>
 <returns>A copy of the input array.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.collect``2(``0[],Microsoft.FSharp.Core.FSharpFunc{``0,``1[]})">
 <summary>For each element of the array, applies the given function. Concatenates all the results and return the combined array.</summary>
 <param name="mapping">The function to create sub-arrays from the input array elements.</param>
 <returns>The concatenation of the sub-arrays.</returns>
</member>
<member name="M:FSharp.Core.Fluent.ArrayExtensions.[]`1.append``1(``0[],``0[])">
 <summary>Builds a new array that contains the elements of the first array followed by the elements of the second array.</summary>
 <param name="array2">The second input array.</param>
 <returns>The resulting array.</returns>
</member>
<member name="T:FSharp.Core.Fluent.ArrayExtensions">
 <summary>Fluent extension operations on arrays.</summary>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.SeqExtensionsConstrained.sumBy``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns the sum of the results generated by applying the function to each element of the sequence.</summary>
 <remarks>The generated elements are summed using the <c>+</c> operator and <c>Zero</c> property associated with the generated type.</remarks>

 <param name="projection">A function to transform items from the input sequence into the type that will be summed.</param>
 <param name="source">The input sequence.</param>

 <returns>The computed sum.</returns>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.SeqExtensionsConstrained.sum``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the sum of the elements in the sequence.</summary>

 <remarks>The elements are summed using the <c>+</c> operator and <c>Zero</c> property associated with the generated type.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The computed sum.</returns>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.SeqExtensionsConstrained.sortDescending``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Yields a sequence ordered descending by keys.</summary>
 
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.SeqExtensionsConstrained.sort``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Yields a sequence ordered by keys.</summary>
 
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.SeqExtensionsConstrained.minBy``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns the lowest of all elements of the sequence, compared via Operators.min on the function result.</summary>

 <param name="projection">A function to transform items from the input sequence into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The smallest element of the sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.SeqExtensionsConstrained.min``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the lowest of all elements of the sequence, compared via <c>Operators.min</c>.</summary>

 <param name="source">The input sequence.</param>

 <returns>The smallest element of the sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.SeqExtensionsConstrained.maxBy``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns the greatest of all elements of the sequence, compared via Operators.max on the function result.</summary>

 <param name="projection">A function to transform items from the input sequence into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The largest element of the sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.SeqExtensionsConstrained.max``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the greatest of all elements of the sequence, compared via Operators.max</summary>

 <param name="source">The input sequence.</param>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>

 <returns>The largest element of the sequence.</returns>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.SeqExtensionsConstrained.distinct``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that contains no duplicate entries according to generic hash and
 equality comparisons on the entries.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.SeqExtensionsConstrained.contains``1(System.Collections.Generic.IEnumerable{``0},``0)">
 <summary>Tests if the sequence contains the specified element.</summary>
 <param name="value">The value to locate in the input sequence.</param>
 <param name="source">The input sequence.</param>
 <returns>True if the input sequence contains the specified element; false otherwise.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.SeqExtensionsConstrained.averageBy``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns the average of the results generated by applying the function to each element 
 of the sequence.</summary>

 <remarks>The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property 
 associated with the generated type.</remarks>

 <param name="projection">A function applied to transform each element of the sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The average.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence has zero elements.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.SeqExtensionsConstrained.average``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the average of the elements in the sequence.</summary>

 <remarks>The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property 
 associated with the element type.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The average.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence has zero elements.</exception>
</member>
<member name="T:FSharp.Core.Fluent.SeqExtensions.SeqExtensionsConstrained">
 <summary>Fluent extension operations on sequences which require constrained types.</summary>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.zip3``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
 <summary>Combines the three sequences into a list of triples. The sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequences are ignored.</summary>

 <param name="source">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>
 <param name="source3">The third input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when any of the input sequences is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Combines the two sequences into a list of pairs. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequence are ignored.</summary>

 <param name="source">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.windowed``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>Returns a sequence that yields sliding windows containing elements drawn from the input
 sequence. Each window is returned as a fresh array.</summary>
 <param name="windowSize">The number of elements in each window.</param>
 <param name="source">The input sequence.</param>
 <returns>The result sequence.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when windowSize is not positive.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.truncate``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>Returns a sequence that when enumerated returns at most N elements.</summary>

 <param name="count">The maximum number of items to enumerate.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.tryPick``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
 <summary>Applies the given function to successive elements, returning the first
 result where the function returns "Some(x)".</summary>

 <param name="chooser">A function that transforms items from the input sequence into options.</param>
 <param name="source">The input sequence.</param>

 <returns>The chosen element or <c>None</c>.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.tryFindIndexBack``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the index of the last element in the sequence
 that satisfies the given predicate. Return <c>None</c> if no such element exists.</summary>
 <remarks>This function digests the whole initial sequence as soon as it is called. As a
 result this function should not be used with large or infinite sequences.</remarks>
 <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
 <param name="source">The input sequence.</param>
 <returns>The found index or <c>None</c>.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.tryItem``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>Tries to find the nth element in the sequence.
 Returns <c>None</c> if index is negative or the input sequence does not contain enough elements.</summary>
 <param name="index">The index of element to retrieve.</param>
 <param name="source">The input sequence.</param>
 <returns>The nth element of the sequence or <c>None</c>.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.tryFindIndex``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the index of the first element in the sequence 
 that satisfies the given predicate. Return <c>None</c> if no such element exists.</summary>

 <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The found index or <c>None</c>.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.tryFindBack``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the last element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.</summary>
 <remarks>This function digests the whole initial sequence as soon as it is called. As a
 result this function should not be used with large or infinite sequences.</remarks>
 <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
 <param name="source">The input sequence.</param>
 <returns>The found element or <c>None</c>.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.tryFind``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the first element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.</summary>

 <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The found element or <c>None</c>.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.toList``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a list from the given collection.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result list.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.toArray``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds an array from the given collection.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result array.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.takeWhile``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns a sequence that, when iterated, yields elements of the underlying sequence while the 
 given predicate returns <c>true</c>, and then returns no further elements.</summary>

 <param name="predicate">A function that evaluates to false when no more items should be returned.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>Returns the first N elements of the sequence.</summary>
 <remarks>Throws <c>InvalidOperationException</c>
 if the count exceeds the number of elements in the sequence. <c>Seq.truncate</c>
 returns as many items as the sequence contains instead of throwing an exception.</remarks>

 <param name="count">The number of items to take.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
 <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the sequence.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.tail``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that skips 1 element of the underlying sequence and then yields the
 remaining elements of the sequence.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.InvalidOperationException">Thrown when the input sequence is empty.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.sortByDescending``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Applies a key-generating function to each element of a sequence and yield a sequence ordered
 descending by keys.  The keys are compared using generic comparison as implemented by <c>Operators.compare</c>.</summary> 
 
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="projection">A function to transform items of the input sequence into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.sortBy``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Applies a key-generating function to each element of a sequence and yield a sequence ordered
 by keys.  The keys are compared using generic comparison as implemented by <c>Operators.compare</c>.</summary> 
 
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="projection">A function to transform items of the input sequence into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.sortWith``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}})">
 <summary>Yields a sequence ordered using the given comparison function.</summary>
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences. The function makes no assumption on the ordering of the original
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>
 <param name="comparer">The function to compare the collection elements.</param>
 <param name="list">The input sequence.</param>
 <returns>The result sequence.</returns>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.skipWhile``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns a sequence that, when iterated, skips elements of the underlying sequence while the 
 given predicate returns <c>true</c>, and then yields the remaining elements of the sequence.</summary>

 <param name="predicate">A function that evaluates an element of the sequence to a boolean value.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>Returns a sequence that skips N elements of the underlying sequence and then yields the
 remaining elements of the sequence.</summary>

 <param name="count">The number of items to skip.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the sequence.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.scanBack``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1)">
 <summary>Like <c>foldBack</c>, but returns the sequence of intermediary and final results.</summary>
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as that
 sequence is iterated. As a result this function should not be used with large or infinite sequences.
 </remarks>
 <param name="folder">A function that updates the state with each element from the sequence.</param>
 <param name="source">The input sequence.</param>
 <param name="state">The initial state.</param>
 <returns>The resulting sequence of computed states.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.scan``2(System.Collections.Generic.IEnumerable{``0},``1,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
 <summary>Like fold, but computes on-demand and returns the sequence of intermediary and final results.</summary>

 <param name="folder">A function that updates the state with each element from the sequence.</param>
 <param name="state">The initial state.</param>
 <param name="source">The input sequence.</param>

 <returns>The resulting sequence of computed states.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.reverse``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a new sequence with the elements in reverse order.</summary>
 <param name="source">The input sequence.</param>
 <returns>The reversed sequence.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.reduceBack``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
 <summary>Applies a function to each element of the sequence, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f i0 (...(f iN-1 iN))</c>.</summary>
 <param name="reduction">A function that takes in the next-to-last element of the sequence and the
 current accumulated result to produce the next accumulated result.</param>
 <param name="source">The input sequence.</param>
 <returns>The final result of the reductions.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.reduce``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
 <summary>Applies a function to each element of the sequence, threading an accumulator argument
 through the computation. Begin by applying the function to the first two elements.
 Then feed this result into the function along with the third element and so on.  
 Return the final result.</summary>

 <param name="reduction">A function that takes in the current accumulated result and the next
 element of the sequence to produce the next accumulated result.</param>
 <param name="source">The input sequence.</param>

 <returns>The final result of the reduction function.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.readonly``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new sequence object that delegates to the given sequence object. This ensures 
 the original sequence cannot be rediscovered and mutated by a type cast. For example, 
 if given an array the returned sequence will return the elements of the array, but
 you cannot cast the returned sequence object to an array.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.pick``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
 <summary>Applies the given function to successive elements, returning the first
 <c>x</c> where the function returns "Some(x)".</summary>

 <param name="chooser">A function to transform each item of the input sequence into an option of the output type.</param>
 <param name="source">The input sequence.</param>

 <returns>The selected element.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown when every item of the sequence
 evaluates to <c>None</c> when the given function is applied.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.permute``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32})">
 <summary>Returns a sequence with all elements permuted according to the
 specified permutation.</summary>

 <remarks>Note that this function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences.</remarks>

 <param name="indexMap">The function that maps input indices to output indices.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when indexMap does not produce a valid permutation.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.mapFoldBack``3(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},``1)">
 <summary>Combines map and foldBack. Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The function is also used to accumulate a final value.</summary>
 <remarks>This function digests the whole initial sequence as soon as it is called. As a result this function should
 not be used with large or infinite sequences.</remarks>
 <param name="mapping">The function to transform elements from the input collection and accumulate the final value.</param>
 <param name="array">The input collection.</param>
 <param name="state">The initial state.</param>
 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
 <returns>The collection of transformed elements, and the final accumulated value.</returns>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.mapFold``4(System.Collections.Generic.IEnumerable{``0},``2,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``3,``2}}})">
 <summary>Combines map and fold. Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The function is also used to accumulate a final value.</summary>
 <remarks>This function digests the whole initial sequence as soon as it is called. As a result this function should
 not be used with large or infinite sequences.</remarks>
 <param name="mapping">The function to transform elements from the input collection and accumulate the final value.</param>
 <param name="state">The initial state.</param>
 <param name="array">The input collection.</param>
 <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
 <returns>The collection of transformed elements, and the final accumulated value.</returns>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.pairwise``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence of each element in the input sequence and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.mapi``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.</summary>

 <param name="mapping">A function to transform items from the input sequence that also supplies the current index.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.map``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.  The given function will be applied
 as elements are demanded using the <c>MoveNext</c> method on enumerators retrieved from the
 object.</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>

 <param name="mapping">A function to transform items from the input sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.get_length``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the length of the sequence</summary>

 <param name="source">The input sequence.</param>

 <returns>The length of the sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.iteri``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}})">
 <summary>Applies the given function to each element of the collection. The integer passed to the
 function indicates the index of element.</summary>

 <param name="action">A function to apply to each element of the sequence that can also access the current index.</param>
 <param name="source">The input sequence.</param>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.iter``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
 <summary>Applies the given function to each element of the collection.</summary>

 <param name="action">A function to apply to each element of the sequence.</param>
 <param name="source">The input sequence.</param>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.Item``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
 <summary>Computes the element at the specified index in the collection.</summary>
 <param name="index">The index of the element to retrieve.</param>
 <param name="source">The input sequence.</param>
 <returns>The element at the specified index of the sequence.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the index is negative or the input sequence does not contain enough elements.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.indexed``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new collection whose elements are the corresponding elements of the input collection
 paired with the integer index (from 0) of each element.</summary>
 <param name="source">The input sequence.</param>
 <returns>The result sequence.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.get_IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns true if the sequence contains no elements, false otherwise.</summary>

 <param name="source">The input sequence.</param>

 <returns>True if the sequence is empty; false otherwise.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.exactlyOne``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the only element of the sequence.</summary>

 <param name="source">The input sequence.</param>

 <returns>The only element of the sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input does not have precisely one element.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.tryLast``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the last element of the sequence.
 Return <c>None</c> if no such element exists.</summary>

 <param name="source">The input sequence.</param>

 <returns>The last element of the sequence or None.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.last``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the last element of the sequence.</summary>
 <param name="source">The input sequence.</param>
 <returns>The last element of the sequence.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input does not have any elements.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.tryHead``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the first element of the sequence, or None if the sequence is empty.</summary>

 <param name="source">The input sequence.</param>

 <returns>The first element of the sequence or None.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.head``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the first element of the sequence.</summary>

 <param name="source">The input sequence.</param>

 <returns>The first element of the sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="System.ArgumentException">Thrown when the input does not have any elements.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.groupBy``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Applies a key-generating function to each element of a sequence and yields a sequence of 
 unique keys. Each unique key contains a sequence of all elements that match 
 to this key.</summary>
 
 <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.</remarks>

 <param name="projection">A function that transforms an element of the sequence into a comparable key.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.forall``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Tests if all elements of the sequence satisfy the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input sequence. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>

 <param name="predicate">A function to test an element of the input sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>True if every element of the sequence satisfies the predicate; false otherwise.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.foldBack``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1)">
 <summary>Applies a function to each element of the collection, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>
 then computes <c>f i0 (... (f iN s)...)</c></summary>
 <param name="folder">The function to update the state given the input elements.</param>
 <param name="source">The input sequence.</param>
 <param name="state">The initial state.</param>
 <returns>The state object after the folding function is applied to each element of the sequence.</returns>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.fold``2(System.Collections.Generic.IEnumerable{``0},``1,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f s i0)...) iN</c></summary>

 <param name="folder">A function that updates the state with each element from the sequence.</param>
 <param name="state">The initial state.</param>
 <param name="source">The input sequence.</param>

 <returns>The state object after the folding function is applied to each element of the sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.findIndexBack``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the index of the last element for which the given function returns <c>true</c>.</summary>
 <remarks>This function digests the whole initial sequence as soon as it is called. As a
 result this function should not be used with large or infinite sequences.</remarks>
 <param name="predicate">A function to test whether the index of a particular element should be returned.</param>
 <param name="source">The input sequence.</param>
 <returns>The index of the last element for which the predicate returns <c>true</c>.</returns>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.findIndex``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the index of the first element for which the given function returns <c>true</c>.</summary>

 <param name="predicate">A function to test whether the index of a particular element should be returned.</param>
 <param name="source">The input sequence.</param>

 <returns>The index of the first element for which the predicate returns <c>true</c>.</returns>

 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.findBack``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the last element for which the given function returns <c>true</c>.</summary>
 <remarks>This function digests the whole initial sequence as soon as it is called. As a
 result this function should not be used with large or infinite sequences.</remarks>
 <param name="predicate">A function to test whether an item in the sequence should be returned.</param>
 <param name="source">The input sequence.</param>
 <returns>The last element for which the predicate returns <c>true</c>.</returns>
 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.find``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns the first element for which the given function returns <c>true</c>.</summary>

 <param name="predicate">A function to test whether an item in the sequence should be returned.</param>
 <param name="source">The input sequence.</param>

 <returns>The first element for which the predicate returns <c>true</c>.</returns>

 <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.where``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true".</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.

 Remember sequence is lazy, effects are delayed until it is enumerated.
 
 A synonym for Seq.filter.</remarks>

 <param name="predicate">A function to test whether each item in the input sequence should be included in the output.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>    
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.filter``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true". This is a synonym for Seq.where.</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.

 Remember sequence is lazy, effects are delayed until it is enumerated.</remarks>

 <param name="predicate">A function to test whether each item in the input sequence should be included in the output.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>    
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.exists``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>Tests if any element of the sequence satisfies the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input sequence. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>

 <param name="predicate">A function to test each item of the input sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>True if any result from the predicate is true; false otherwise.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.distinctBy``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Returns a sequence that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.</summary>

 <param name="projection">A function transforming the sequence items into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.countBy``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Applies a key-generating function to each element of a sequence and returns a sequence yielding unique
 keys and their number of occurrences in the original sequence.</summary>
 
 <remarks>Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.</remarks>

 <param name="projection">A function transforming each item of the input sequence into a key to be
 compared against the others.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.compareWith``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Compares two sequences using the given comparison function, element by element.
 Returns the first non-zero result from the comparison function.  If the end of a sequence
 is reached it returns a -1 if the first sequence is shorter and a 1 if the second sequence
 is shorter.</summary>

 <param name="comparer">A function that takes an element from each sequence and returns an int.
 If it evaluates to a non-zero value iteration is stopped and that value is returned.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The first non-zero value from the comparison function.</returns>

 <exception cref="System.ArgumentNullException">Thrown when either of the input sequences
 is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.collect``3(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Applies the given function to each element of the sequence and concatenates all the
 results.</summary>

 <remarks>Remember sequence is lazy, effects are delayed until it is enumerated.</remarks>

 <param name="mapping">A function to transform elements of the input sequence into the sequences
 that will then be concatenated.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.choose``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
 <summary>Applies the given function to each element of the list. Return
 the list comprised of the results "x" for each element where
 the function returns Some(x).</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not
 be accessed concurrently.</remarks>

 <param name="chooser">A function to transform items of type T into options of type U.</param>
 <param name="source">The input sequence of type T.</param>

 <returns>The result sequence.</returns>
 
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.cache``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that corresponds to a cached version of the input sequence.
 This result sequence will have the same elements as the input sequence. The result 
 can be enumerated multiple times. The input sequence will be enumerated at most 
 once and only as far as is necessary.  Caching a sequence is typically useful when repeatedly
 evaluating items in the original sequence is computationally expensive or if
 iterating the sequence causes side-effects that the user does not want to be
 repeated multiple times.

 Enumeration of the result sequence is thread safe in the sense that multiple independent IEnumerator
 values may be used simultaneously from different threads (accesses to 
 the internal lookaside table are thread safe). Each individual IEnumerator
 is not typically thread safe and should not be accessed concurrently.</summary>

 <remarks>Once enumeration of the input sequence has started,
 it's enumerator will be kept live by this object until the enumeration has completed.
 At that point, the enumerator will be disposed. 

 The enumerator may be disposed and underlying cache storage released by 
 converting the returned sequence object to type IDisposable, and calling the Dispose method
 on this object. The sequence object may then be re-enumerated and a fresh enumerator will
 be used.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:FSharp.Core.Fluent.SeqExtensions.IEnumerable`1.append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>Wraps the two given enumerations as a single concatenated
 enumeration.</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed
 concurrently.</remarks>

 <param name="source1">The first sequence.</param>
 <param name="source2">The second sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="System.ArgumentNullException">Thrown when either of the two provided sequences is
 null.</exception>
</member>
<member name="T:FSharp.Core.Fluent.SeqExtensions">
 <summary>Fluent extension operations on sequences.</summary>
</member>
<member name="">

</member>
<member name="T:System.AssemblyVersionInformation">

</member>
</members>
</doc>
