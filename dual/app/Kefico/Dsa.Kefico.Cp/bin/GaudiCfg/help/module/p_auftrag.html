<HTML>
<HEAD>
<TITLE>P_AUFTRAG</TITLE>
<META NAME="Generator" CONTENT="KDOC ">
</HEAD>
<BODY bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#000099" alink= "#ffffff">

<table BORDER=0 COLS=1 WIDTH="100%" BGCOLOR="#FFFFCC" NOSAVE >
<tr ALIGN=CENTER VALIGN=CENTER NOSAVE>
<td NOSAVE><font face="Arial,Helvetica"><font size=+2></font></font>
<br><font face="Arial,Helvetica"><font size=+2>CCS Modul &nbsp;&nbsp;<b>P_AUFTRAG</b></font></font>
<br>&nbsp;</td>
</tr>
</table>
<PRE>
   $Id: p_auftrag.C,v 1.48 2005/12/19 14:33:11 cvs Exp $
   ---------------------------------------------------------------------
   Kurzbeschreibung: 	Auftrag an die PSS/SKM senden.
   ---------------------------------------------------------------------
   Projekt:		CCS
   Sourcefile:		p_auftrag.C
   Autor:		RtW/TEF72-Keppler (02.04.96)
   Zielsystem:		HP9000/V743 (HP-RT 2.0x), /Sxxx (HP-UX 9.0x)
   Sprache:		C++
   ---------------------------------------------------------------------
   Prototyp:
   MPI Schnittstelle
   void p_init(shm_stringpointer *zeilen_info
	   ,shm_stringpointer    *zeilen_wert
	   ,long index1
	   ,long anzahl)
   
   ---------------------------------------------------------------------
   Aufruf: im Vectorinterpreter
   
	 (*funktionen[modulnummer])
	    (Ssp_expand_zeile
	     ,Ssp_expand_wert
	     ,p_verwaltung-&gt;begin_modulblock
	     ,p_verwaltung-&gt;anzahl_modulparameter);

   

      ---------------------------------------------------------------------
   Funktionsbeschreibung:
   Dieses Modul dient zur Auftragsvergabe an die PSS. Hiermit kÎnnen beliebige
   Strings an die PSS bzw. an das SG gesendet werden. Die Auswertung der 
   Antwort erfolgt nicht in diesem Modul. Die Antwort wird im shared Memory
   abgelegt und kann dort z.B. vom Modul p_zerlege_string geholt und 
   verarbeitet werden.
   
   Einfuehrung von langen Variablen:
   Der Befehl C ist bei diesen Variablen nicht erlaubt.
   Eine Konvertierung bei 0x findet nicht statt.
   
   Beschreibung der ModulÏbergabeparameter:</pre><b><a name="param1">1</a> PRUEFSCHRITT</b><pre>
   	GAUDI PrÏfschritt
   ------------------------------</pre><b><a name="param2">2</a> POSITION</b><pre>
   	PAV- Position
   ------------------------------</pre><b><a name="param3">3</a> BEFEHL</b><pre>	Steuerbefehl fÏr die PSS/SKM
    			Diese Befehle gelten auch fÏr die SKM falls dies 
			explizit vermerkt ist.
	ASCCAN_SWITCH:	Bei ASCCAN werden die KWP2000-Signale für die K-Line einfach auf den
	(nur SKMlight)	CAN-Bus gelegt (nicht zu verwechseln mit KWP2000 over CAN). Für den 
			Host sieht es so aus, als würde über K-Line kommuniziert werden. Der 
			Host muss lediglich vor der Kommunikation den Befehl ASCCAN_SWITCH(1) 
			und am Ende der gesamten Kommunikation wieder ASCCAN_SWITCH(0) absetzen.
			Der Befehl ASCCAN_SWITCH nimmt die hardwaremäßige Umschaltung vor.
			DATUM 0 -&gt; ASCCAN wird deaktiviert (Standard)
			DATUM 1 -&gt; ASCCAN wird aktiviert
			Es ist zu beachten, dass für ASCCAN ein spezieller Adapterstecker
			notwendig ist. Solange ASCCAN aktiviert ist, kann über die normale
			CAN- und K-Line-Schnittstelle nicht kommuniziert werden!
	BEDIENBLOCK:	Der Block mit dem die Komunikation mir dem SG 
			aufrechterhalten werden soll, kann hier der PSS
			mitgeteilt werden. Dieser Befehl muÞ nach Initialisierung
			der Schnittstelle und vor reizen des SG erfolgen.
			UnterstÏtzt bei:
				KP2000
				BLOCK
        ECHOBLOCK: 	Echofunktionalität auf K-Line: 
                        Stellt einen Block ein, der nach Empfang einer definierten Botschaft
                        gesendet wird.
                        Wird nicht bei Protokollen über K-Line unterstützt.
                        (siehe auch ECHOVERGL_BLOCK)
        ECHOVERGL_BLOCK: Echofunktionalität auf K-Line.
                        Stellt einen Block ein, auf den, die über die K-line empfangenen Daten 
                        verglichen werden. Die Echofunktionalität wird aktiviert, wenn die
                        Kommandos ECHOBLOCK und ECHOVERGL_BLOCK abgesendet wurden.
                        Die Reihenfolge ist egal. Der Echoblock wird nur 1 mal abgesendet, dann
                        wird die Funktion deaktiviert und muss ggf. neu aufgesetzt werden.
                        Wird nicht bei Protokollen über K-Line unterstützt.
                        (siehe auch ECHOBLOCK)                      
	BUILD_CS:	Dieser Befehl bildet eine Checksumme Ïber den im Parameter
			Daten angegebenen Datenbereich.
			Stringaufbau im Parameter DATUM:
				Anfangsadresse 	= 00..FF
				Endadresse 	= 00..FF
			UnterstÏtzt bei:
				EEPROM
	BAUDRATE:	FÏr PSS: Dient der Umschaltung der Baudrate
			In DATUM ist "tthh" einzutragen.
			tt= tausender der Baudrate = 00..FF in Hex
			hh= hunderter der Baudrate = 00..FF in Hex
	CAN_BKGND_START:Startet im Hintergrund die Embedded CAN-Restbussimulation.
	(nur SKMlight)	Falls parallel dazu beispielsweise der "KWP2000 on CAN"-
			Tester verwendet werden soll, muss darauf geachtet werden
			dass alle CAN-Bus-Teilnehmer dieselben CAN-Bus-
			Eigenschaften einstellen.
			Modus "S" verwenden!
	CAN_BKGND_STOP:	Beendet die Embedded CAN-Restbussimulation.
	(nur SKMlight)	Modus "S" verwenden!
	CAN_BKGND_ON_KEY:Über diesen Befehl kann die Embedded CAN-Restbussimulation
	(nur SKMlight)	durch "Tastatur-Zeichen" manipuliert werden.
			DATUM ist 1 Byte ("Tastatur-Zeichen") als Hex-Wert.
			Beispiel: Zeichen 'a' wird mit 61 dargestellt.
			Modus "S" verwenden!
	COMBLOCK:	Komunikation mit dem SG. Es wird ein Block
			zum SG gesendet und auf die Antwort vom SG 
			gewartet. Die Antwort vom SG wird zum Host 
			weitergeleitet.
			Der zum SG zu sendende Block ist im Parameter
			DATUM einzutragen.
			UnterstÏtzt bei:
				KP2000
				DDS
				JECS: PS-Befehl
				EASY
				K71
				BLOCK
    	COMBLOCK_MAD:	Wie COMBLOCK, jedoch wird nach empfang der Botschaft
			das Senden des SG gestoppt.
			UnterstÏtzt bei:
				JECS: MAD-Kommando
    	DLM_NACHLADEN:	Mit diesem Befehl wird das Downloadmodul aus dem 
	(nur SKM)	pcc-File zum SG geladen.
			UnterstÏtzt bei: (nur SKM)
				Prokist
    	DREZ_FUEHLER:	Mit diesem Befehl wird Frequenz fuer die Drehzahlfuehler der
			ABS-Geraete angeschaltet. 
			Eingabe in DATUM:	NN MM F1 F1 T1 T1.... F4 F4 T4 T4
			
			NN = Nummer des Drehzahlfuehler in Ascii
				31 =&gt; DF1 ...
			Prokist-Pins am 80C176-Controller Ausgaenge
			P2.3	HSK_0	CC3IO	DF1=&gt;31	DZF_VL	Pin13
			P2.4	HSK_1   CC4IO	DF2=&gt;32	DZF_HR	Pin12
			P2.5	HSK_2	CC5IO	DF3=&gt;33	DZF_VR	Pin11
			P2.6	HSK_3	CC6IO	DF4=&gt;34	DZF_HL  Pin10
			MM = Mode
				41= A=	Activate
				44= D=	Deactivate
				48= H= 	statisch high	
				4C= L= 	statisch Low
			F1F1 = Frequenz in Hz (Hex) (0000..FFFF)
			
			Bsp.: fuer DATUM
		        	31 41 03 E8  aktiviere DF1 mit 1000Hz
		        	
		     Neues Feature PWM
			NN = Mode 
				 4D= M= Activate PWM
				 44= D= Deactivate PWM
			MM = Mode 
				 45= E= Alle Ausgaenge mit dem gleichen Signal
				    F1F1 = Frequenz in Hz (Hex) (0000..FFFF)
					   fuer alle Kanaele
				    T1T1 = Tastverhaeltnis fuer alle Kanaele
				 46= F= Wie E jedoch werden die Signale
					invertiert ausgegeben.
				 44= D= Jeder Ausgang eigenes Signal
				 
			F1F1..F4F4= Frequenz in Hz (Hex) (0000..FFFF)
			T1T1..T4T4= Tastverhaeltnis (0000..FFFF)
			
			Bsp.: fuer PWM
			      4D 45 07 D0 00 03 aktiviere DF1 -DF4 mit 2000Hz
						und Tastverhaeltnis 1/3
			   
			Unterstuetzt bei: (nur SKM und SKMlight)
				alle Protokolle
                        Ausgang auf SKMlight: Buchse X5 (25polige D-sub) Pin 7
	EMPFANG_SG:	Die Schnittstelle wird auf hoeren geschaltet. Es muÞ 
			innerhalb der Timeoutzeit eine Botschaft vom SG 
			empfangen werden, sonst erfolgt eine Fehlermeldung.
			ACHTUNG: 
			Ein schalten der Komunikationsleitung auf high wÌhrend 
			die Schnittstelle auf hoeren geschaltet ist, fÏhrt zu 
			falschen (sinnlosen) empfangenen Botschaften, und ist 
			daher nicht mÎglich.
			UnterstÏtzt bei:
				DDS
				EASY
				K71
	FILE_LOAD:	Syntax wie FLASH_PROG, jedoch wird das File nur bei 
			nicht vorhandensein auf die SKM geladen. Ist das File 
			schon vorhanden, dann findet keine Aktion statt.
			UnterstÏtzt bei: (SKM)
				Alle Protokolle
	FILE_DELETE:	Alle Files auf der SKM//PSS werden gelÎscht. Diese Option zwingt
	                zum nachladen aller Files. !ACHTUNG! Diese Option darf nicht bei
			jedem Durchlauf stattfinden und muÞ z.B. duch eine IF - THEN - ELSE
			Struktur abgefangen werden (nur RÏstlauf o.Ì.)
				Alle Protokolle
	FLASH_PROG:	Mit diesem Befehl kann eine Flashprogrammierung durch-
			gefÏhrt werden. In der Vatiablen DATUM sind die 
			notwendigen Informationen an die PSS/SKM einzutragen.
			(Siehe auch PSS-Doku. oder SKM-Doku) Ist das zu
			programmierende File mit der Endung .bin
			der PSS/SKM nicht bekannt, so wird dies hier automatisch 
			geladen, und dann die Programmierung durchgefÏhrt.
			Beispielstring in DATUM:
			AA||&lt;filename&gt;||MM||LL||OOOOOO||NNNNNN||
			
			AA      = String der vor die Daten zum SG gehÌngt wird
				  also z.B. der Blocktitel und Adressen.
			MM 	= Modus:		
			00 =&gt;	Die LÌnge LL ist die relev. DatenlÌnge fÏr die BlÎcke zum SG
			01 =&gt; 	Die LÌnge zum SG steht im File
			02 =&gt; 	Es wird mit Offset und LÌnge zugegriffen
				Die LÌnge LL ist die relev. DatenlÌnge fÏr die BlÎcke zum SG
			03 =&gt; 	Es wird mit Offset und LÌnge zugegriffen
				Die LÌnge zum SG steht im File
			LL	=LÌnge :		LÌnge des Blocks zum SG. (0..FF)
			Bei Modus 02 oder 03: OOOOOO und NNNNNN
			OOOOOO=Offset:	Offset mit dem auf das File zugegriffen werden soll
			NNNNNN=LÌnge: 	Zu programmierende LÌnge in Byte
			
			UnterstÏtzt bei:
				Alle Protokolle
	FLASH_ANTW_EIN:	Mit diesem Befehl kann die Antwort die vom SG bei der
			Flashprogrammierung erwartet wird eingestellt werden.
			Mit setzen des Initparameters 0x80 = FLASH_SG_ANTW = 02
			wird die Antwort des SG's dann mit dieser Botschaft auf 
			Ûbereinstimmung verglichen (nur die Nutzdaten einschl.
			Blcktitel).
			UnterstÏtzt bei: (SKM/PSS)
				Alle Protokolle 
	FLASH_PROG_PAR:	Wie FLASH_PROG, jedoch kÎnnen hier im Zusammenhang mit
			PARA3 = L mehrere PSS'n nacheinander dazu veranlaÞt 
			werden, einen Flashdatensatz zum SG zu programmieren.
			Die Antwort OK wird zurÏckgegeben befor die Flash-
			programmierung erfolgt.
			Die Antwort fÏr die Richtigkeit der Programmierung 
			kann spÌter mit einem erneuten Modulaufruf 
			geholt werden, indem PARA3 = G gesetzt wird.
			Bevor eine andere PSS angesprochen wird, muÞ zuerst die 
			Adresse mit dem Modul P_STEUER geÌndert werden.
			UnterstÏtzt bei:
				Alle Protokolle
        GET_DIGITAL_IN:
        (nur SKMlight)  liest die digitalen Eingänge von der SKMlight zurueck (1 Byte)
                        Es stehen 5 Kanäle zur Verfügung (falls nicht im gewählten Protokoll
                        benoetigt.)
                        Das Ergebnis kann mit dem Modul p_zerlege_str ausgewertet werden. 
                        Die Bits 0,1 und 7 sind immer 1. Die relevanten bits liegen also
                        von Bit 2-6. 
                        Z.B.:	ERGEBNIS = 87	-&gt; IN1 auf high alle anderen auf 0 
                                ERGEBNIS = 97   -&gt; IN1 und IN3 auf high
	INIT_PROTOCOL:	Hiermit wird initialisiert, ob 	(alt: INIT_PRUEFUNG)
	(nur SKM)	E = EndprÏfung 
			Z = ZwischenprÏfung oder
			P = Programmierung des SG
			gewÏnscht wird. Das Zeichen E/Z/P muÞ unter Datum 
			eingetragen werden.
			UnterstÏtzt bei: (nur SKM)
				Prokist 
	KOMM_ENDE:	Hiermit beendet die Schnittstelle die Kommunikation mit 
			dem SG. D.h., daÞ eine Bedienung der Schnittstelle nicht 
			mehr erfolgt. 
			Wird dieser Befehl vor Abschalten des SG nicht an die 
			Schnittstelle gegeben, so wird ein Timeout abgewarte, 
			und die PrÏfung verzÎgert sich entsprechend.
			UnterstÏtzt bei:
				Alle Protokolle
	LOESCHE:	Wie Befehl COMBLOCK, jedoch wird der Befehl nur unter 
			folgenden Bedingungen ausgefÏhrt.
			1. Der Standtyp muÞ HT sein.
			2. Die Pruefung muÞ bis hier Fehlerfrei gelaufen sein.
			3. Es muÞ die letzte Wiederholpruefung sein.
			UnterstÏtzt bei: (SKM und PSS)
				Alle Protokolle	
                                
        MERKE:		Die jetzt bei Parameter DATUM eingetragenen Daten 
                        werden gespeichert.Und bei Befehl REIZ_PAV mit PARA01 =10
                        verwendet. 
                        Notwendig für Workarround Reizen des NEC mit Makro K2000INI
                        synchronem Protokoll. 
	MELEXIS_CLK_SWITCH:
	(nur SKMlight)	Es gibt Fälle, in denen nach Absetzen spezieller Melexisbefehle die
			Taktausgabe ausgeschalten wird. Über MELEXIS_CLK_SWITCH kann die
			Taktausgabe wieder gestartet werden.
			DATUM (1 Byte): 01 =&gt; Taktausgabe wird gestartet
			                00 =&gt; Taktausgabe wird ausgeschalten
	PAS4_INIT:	Schreibt die Settings (Parameter), die für die PAS4-Kommunikation
	(nur SKMlight)	verwendet werden. Hierfuer muessen die Parameter jedoch zuerst mit
			dem Modul p_init besetzt werden.
			DATUM: keines
	PAS4_COMMAND:	Sendet den übergebenen PAS4-Befehl an den PAS4-Sensor.
	(nur SKMlight)	DATUM: Byte 1: Bit0 = A4, Bit1-3 = I0-I2, Bit4-7 werden ignoriert
			       Byte 2: Bit0-3 = D0-D3, Bit4-7 = A0-A3
	PAS4_PROGRAMMING:
	(nur SKMlight)	Erlaubt das Programmieren/Brennen von bis zu 20 Bits im PROM des
			PAS4-Sensors. Dabei kann das Datum von PAS4_COMMAND bis zu 5 mal direkt
			hintereinander liegend angegeben werden. Folgende Besonderheiten sind
			zu beachten:
			a) Bei den Daten (D0-D3) können jeweils mehrere Datenbits gesetzt sein.
			b) Wird das Datum mehrmals angegeben, dann müssen die Instructionsbits
			   (I0-I2) jeweils gleich sein.
			Dieser Befehl kehrt bereits zurück, BEVOR er vollständig abgearbeitet
			wurde!
			DATUM: Byte 1: Bit0 = A4, Bit1-3 = I0-I2, Bit4-7 werden ignoriert
			       Byte 2: Bit0-3 = D0-D3, Bit4-7 = A0-A3
			       Byte 1 und 2 können bis zu 5 mal angegeben werden (max. 5*2 Bytes).
	PAS4_READING:	Initiiert das Lesen von bis zu 64 Bits aus dem PAS4-Sensor. Die Anfangs-
	(nur SKMlight)	und Endadresse wird angegeben und für jede Adresse werden 4 Datenbits
			ausgelesen. Die Antwortdaten selbst werden von der SKMlight nicht 
			ausgewertet. Dieser Befehl kehrt bereits zurück, BEVOR er vollständig
			abgearbeitet wurde!
			DATUM: Byte 1: Bit0 = A4, Bit1-3 = I0-I2, Bit4-7 werden ignoriert
			       Byte 2: Bit0-3 = D0-D3, Bit4-7 = A0-A3
			       Byte 3: Bit0-4 = A0-A4 (Endadresse)
			In Byte 1-2 ist die Startadresse und in Byte 3 die Endadresse enthalten.
			Die Datenbits aus Byte 1 werden z.Zt. nicht verwendet und sollten auf  
			0001 gesetzt sein.
	PAS4_SET_I0_1_2:Hiermit können die Ausgänge I0, I1 und I2 (Instruction) beliebig gesetzt
	(nur SKMlight)	werden.
			DATUM: Byte 1: Bit0-3 = I0-I2, Bit4-7 werden ignoriert
	PCC_DOWNLOAD:   Wie FLASH_LOAD, jedoch wird die TTNr. nicht automatisch 
	(nur SKM)	an den Pfad angehaengt.
			Die PCC-Files muessen somit unter /hw/pcc/ stehen.
			Sollten hier Subdirectories verwendet werden, so muessen
			diese dem Filenamen vorangestellt werden.
			/hw/pcc/&lt;Subdir&gt;/&lt;Subdir&gt;/&lt;filename&gt;
	PCC_LOAD:	Wie FILE_LOAD, jedoch wird die TTNr. nicht automatisch 
	(nur SKM)	an den Pfad angehaengt.
			Die PCC-Files muessen somit unter /hw/pcc/ stehen.
			Sollten hier Subdirectories verwendet werden, so muessen
			diese dem Filenamen vorangestellt werden.
			/hw/pcc/&lt;Subdir&gt;/&lt;Subdir&gt;/&lt;filename&gt;
        PPS_COM_SPI:	Es werden ueber die SPI daten gesendet oder gelesen. 
        (nur SKMlight)  Die Daten werden immer 16 Bit weise gesendet. 
                        Es können max. 16 * 2 Bytes gesendet/gelesen werden. Es ist 
                        nur eine geradzahlige Menge von Bytes zugelassen. (2..4 ..6.....32)
        PPS_COLLECT_DATA:
        (nur SKMlight)  Dieser Befehl gibt ein Triggersignal auf dem Output Port 2 aus, wartet die 
                        eingetragene Zeit in ms ab, und beginnt mit dem einlesen der gewuenschten
                        Anzahl von Druckwerten aus den angegebenen Kanaelen.
                        Wartezeit nach Trigger bis lesen in ms
                        Kanalwahl: bis zu 3 Kanäle die der ASIC cg974 beherrscht.
                        Anzahl der gelesenen Druckwerte.
                        Dies Parameter bitte mit p_init initialisieren.
        PPS_COLLECT_DATA_ALL:
                        wie PPS_COLLECT_DATA jedoch werden nicht nur Druckwerte, sondern alle Werte gesammelt.
        PPS_COLLECT_DATA_REL:                
                        wie PPS_COLLECT_DATA jedoch werden nur relative Druckwerte gesammelt. Die absoluten
                        Druckwerte werden verworfen.
        PPS_COLLECT_DATA_RAW:                
                        wie PPS_COLLECT_DATA jedoch alle Werte gesammelt. Es werden keine Werte verworfen, auch nicht
                        die oversampelten.
        PPS_SENSOR_ON_COLLECT_DATA:
        PPS_SENSOR_ON_COLLECT_DATA_ALL:
        PPS_SENSOR_ON_COLLECT_DATA_REL:
        PPS_SENSOR_ON_COLLECT_DATA_RAW:
        (nur SKMlight)  Diese Befehle sind identisch zu ihrem jeweiligen Pendant (s.o.) mit dem Unterschied,
                        dass zuerst der Sensor eingeschalten wird.
        PPS_GET_COLLECTED_DATA:
        (nur SKMlight)  Diese Befehl liest die bei dem Befehl PPS_COLLECT_DATA erhaltenen daten
                        aus der SKMlight sortiert nach Kanal aus.
                        DATUM: Kanalwahl: 1 Byte:  01 = Kanal 1   (nur 1 Kanal moeglich)
                                                   02 = Kanal 2
                                                   04 = Kanal 3
                               Blockwahl  1 Byte   0...4   Da bis zu 5000 Daten pro Kanal moglich sind muessen
                                                           dies in Blöcken zu je 1000 von der SKMlight geholt 
                                                           werden. 0=1..1000
                                                                   1=1001-2000
                                                                   2=2001-3000 etc.
                        Beispiel: Kanal 2 u. Datum 1001-2000:  DATUM = 0201
        PPS_GET_STATUS: Liest die Statusinformationen die der Sensor in der Initialisierungsphase
        (nur SKMlight)  sendet aus.
                        Hierzu muss der Befehl vor oder waehrend der Initphase abgesetz werden. 
                        ACHTUNG: Es wird maximal 250 ms auf die ID's gepollt.
                        DATUM: Kanalwahl: 1 Byte:  01 = Kanal 1  (nur 1 Kanal moeglich)
                                                   02 = Kanal 2
                                                   04 = Kanal 3
                        Es werden die Statusinfos zurück gegeben (8 Byte)
        PPS_GET_STATUS_EXACTLY:
                        Wie PPS_GET_STATUS, jedoch muessen von der 16-fachen Wiederholung der Daten mindestens
                        15 Datenwerte richtig erkannt werden. Ansonsten wird eine Fehlermeldung zurück gegeben.
        PPS_GET_STATUS_VERY_EXACTLY:
                        Wie PPS_GET_STATUS, jedoch muessen von der 16-fachen Wiederholung der Daten alle
                        16 Datenwerte richtig erkannt werden. Ansonsten wird eine Fehlermeldung zurück gegeben.
        PPS_GET_ABS_PRESSURE:
        (nur SKMlight)  Liest die absoluten Druckwerte P1 und P2 mit ID's aus dem 
                        PPS1-Sensor aus. Hierzu wird maximal 300 ms auf die ID's gepollt, dann
                        wird die Aufgabe abgebrochen. 
                        DATUM: Kanalwahl: 1 Byte:  01 = Kanal 1   (nur 1 Kanal moeglich)
                                                   02 = Kanal 2
                                                   04 = Kanal 3
                        Antwortdaten: PPS-ID1, P1, PPS-ID2, P2  (8 Bytes)                       
        PPS_SENSOR_ON_GET_STATUS:
        (nur SKMlight)  Schaltet den PPS1-Sensor an und liest anschließend die Statusinformationen (siehe
                        PPS_GET_STATUS_EXACTLY), die der Sensor in der Initialisierungsphase sendet. 
                        DATUM: Kanalwahl: 1 Byte:  01 = Kanal 1  (nur 1 Kanal moeglich)
                                                   02 = Kanal 2
                                                   04 = Kanal 3
                        Es werden die Statusinfos zurück gegeben (8 Byte)
        PPS_SENSOR_ON_GET_STATUS_PRESSURE:
        (nur SKMlight)  Schaltet den PPS1-Sensor an und liest anschließend die Statusinformationen (siehe
                        PPS_GET_STATUS_EXACTLY) und den Absolutdruck (siehe PPS_GET_ABS_PRESSURE).
                        DATUM: Kanalwahl: 1 Byte:  01 = Kanal 1  (nur 1 Kanal moeglich)
                                                   02 = Kanal 2
                                                   04 = Kanal 3
                        Es werden die Statusinfos und die Druckwerte mit IDs (PPS-ID1, P1, PPS-ID2, P2) 
                        zurück gegeben - insgesamt 8 + 8 Bytes.
	PROG_SPANNUNG:	Hiermit kann die von der SKM  erzeugte Programmierspannung
			eingestellt werden.
			Eintrag in DATUM: &lt;Spannung in mV&gt;\\&lt;Mode&gt;
				Z.B.	   3200\\00 =&gt; 3,2 V mit Mode = 0
				Mode: 00 = Interne Reverenz, Prog.Spannung geschaltet
				Mode: 01 = Externe Referenz,Prog.Spannung geschaltet
				Mode: 02 = Ausgangsrelais wird geoeffnet
	PRUEFMODUL:	Mit diesem Befehl wird die SKM veranlasst eine Pruef-
	(nur SKM)		sequenz aus dem pms-File abzuarbeiten.
			Das entsprechende Label muss im Parameter DATUM angegeben
			werden. (Z.B. LABEL_55)
			Dieses Label muÞ selbstverstÌndlich im pms-File 
			wiederzufinden sein.
			UnterstÏtz bei: (nur SKM)
				Prokist
	PWM_START:	Startet die Pulsweitenmodulation mit folgenden Daten
	(nur SKM_LIGHT)	Eintrag in DATUM
			Frequenz: 	4Byte in Hex (10000Hz =&gt; 00 00 27 10)
			Highfase in %:	1Byte in Hex (75% =&gt; 4B)
			Obiges Eingabebeispiel in DATUM :  000027104B
			Es werden also immer 5 Byte erwartet. 
	PWM_STOP 	Stoppt die PWM
	(nur SKM_LIGHT) DATUM: kein Eintrag
	
	READ_EEPROM:	Dieser Befehl liest aus einem EEPROM die Daten eines
			Adressbereiches von Anfangsadresse bis Endadresse aus.
			Aufbau des Datenstrings: 
				Anfangsadresse 	= 00..FF
				Endadresse 	= 00..FF
			UnterstÏtzt bei:
				EEPROM (PSS)
	REIZEN: 	Reizen des SG.
			UnterstÏtzt bei:
				KP2000: (5-Baud Reizung)
				JECS
	REIZ_MA:	Reizen des SG mit Massetastung.
			Nach Massetastung meldet sich das SG. Die PSS empfÌngt 
			die Meldung, und gibt an den Host ein OK zurÏck.
			UnterstÏtzt bei:
				KP2000
				DDS
				K71
	REIZ_MA_E3:	Reizen des SG mit Massetastung.
			Nach Massetastung meldet sich das SG. Die PSS/SKM empfÌngt 
			die Meldung, und gibt sie an den Host weiter.
			Bei Fehler SG_ANTWORTET_NICHT wird als Status OK zurÏck
			gegeben.
			Als Daten wird E3E3E3 an den Host zurÏck gegeben.
			UnterstÏtzt bei:
				KP2000
	REIZ_PO:	Reizen des SG durch Power On (einschalten UBATT).
			Die Schnittstelle empfÌngt die Meldung.
			Daraufhin kann mit normaler Kommunkation weiter gemacht werden.
	REIZ_PO_KEY:	Reizen des SG durch Power On (einschalten UBATT).
			Nach Power On meldet sich das SG mit den Key Bytes. 
			Die Schnittstelle empfÌngt die Meldung, und den darauf folgenden
			Acknowledge Block und gibt dann dem Host ein OK zurÏck.
			UnterstÏtzt bei:
				K71
				KP2000(SKM)
	REIZ_PAV:	PARA01:0 -&gt; Keine Reizung
			       1 -&gt; 5 Baud Reizung
			       2 -&gt; Massetastung
                              10 -&gt; Protokolleinstieg in NEC-Prozessor KP2000 synchron 
                                    zuvor muss Modulaufruf p_auftrag mit Befehl MERKE erfolgen.
                                    hier bei Daten &lt;reset command&gt; und &lt;bootstrap command&gt; 
                                    eingeben.
                              11 -&gt; Handshake für synchrones KP2000 einschalten.
                              
			PARA02:0 -&gt; keine Reizung -&gt; Keine Funktion des Moduls
			Daraufhin kann mit normaler Kommunkation weiter gemacht werden.
	RELAIS_CLOSE:   Die bei der Initialisierung eingeschalteten Relais kÎnnen
			hier nach einem RELAIS_OPEN wieder geschlossen werden.
			UnterstÏtzt bei:
				Alle Protokolle
	RELAIS_OPEN:    Die bei der Initialisierung eingeschalteten Relais kÎnnen
			hier geÎffnet werden.
			UnterstÏtzt bei:
				Alle Protokolle
        REQUEST_TRIGGER:
                        Einschalten eines Triggers:Der Trigger kommt, während eine Botschaft 
                        zum ECU gesendet wird. 
                        SKMlight-&gt;Buchse X5-&gt;Pin 21
                        DATUM: =00 -&gt; kein Trigger (Trigger ausschalten)
                               =01 -&gt; Trigger einschalten
                        Unterstützt bei:
                           (derzeit nur KWP2000 über CAN bei SKMlight)
	RESET:		Es wird ein Reset auf die Schnittstellenkarte ausgegeben.
				Alle Protokolle  
	RESETTEST:	Resettest fÏr das DDS-SG.
			Es wird eine Botschaft zum SG gesendet, und es darf 
			keine Antwort zurÏckkommen. Dann ist dieser Test OK.
			UnterstÏtzt bei:
				DDS
	RETURN:		RÏcksprung aus Protokoll ohne die Initialisierungs-
			parameter zu Ìndern.			
			UnterstÏtzt bei:	(nur SKM)
				Alle Protokolle
	SAFE_STATE:	Prokist-Pins in den Anfangszustand setzen. 			
			UnterstÏtzt bei:	(nur SKM)
				Prokist
	SEED_KEY:   	Seed and Key Verfahren fÏr EDC 15 C. Es werden hierbei 2
			Kommunikationen mit dem SG aufgenommen, die im 
			DATUM eingetragen werden mÏssen.
			B1B1B1B1...||MM||B2B2BK0K1K2K3B2B2....||
			B1 = Botschaft 1 
			B2 = Botschaft 2
			K0 - Kn = Platzhalter fÏr Key
			MM = Mode : 02 = EDC15 C (access - Mode aus Botschaft B1)
			03 =  (access - Mode aus INIT-feld 0xE0)
			UnterstÏtzt bei:	(nur PSS)
			Alle Protokolle
	SENDBLOCK:	Siehe SEND_SG (unten):
			Unterstuetzt bei: 	( SKM)
			alle Protokolle (ohne NOP)
	SEND_SG:	Die eingegebene Botschaft wird an das SG gesendet. Es
			wird nicht auf eine Antwort gewartet. Die Schnittstelle
			liefert sofort ein OK zurÏck.
			Eine eventuelle Antwort vom SG geht verloren.
			UnterstÏtzt bei: (nur PSS)
				K71
				BLOCK
        SET_DIGITAL_OUT:
        (nur SKMlight)  Setzt die digitalen Ausgänge auf den mitgegebenen Wert (1 Byte)
                        Es stehen 6 Kanäle zur Verfügung (falls nicht im gewählten Protokoll
                        benoetigt.
                        Z.B.:	DATUM = 05	-&gt; OUT 0 und OUT 2 auf high
                        ACHTUNG: 
                        Dies sollte mit der Funktion e_bits realisiert werden.
                        Diese Funktion ist nur fuer Testzwecke. 
	SET_PROKI_L:	Setzen und zuruecksetzen der Leitungen, die fÏr Prokist
			Verwendung finden. (TP)
			DATUM: DD DD	=&gt; 16 Bit	(0000....FFFF)
			Bit	15 - 12 =&gt; Handschakeleitungen DF4-DF1 (Pin 10-13)
			Bit	11 - 8  =&gt; Resetleitungen      RS4-RS1 (Pin 6-9)
			Bit	7	=&gt; frei
			Bit	6	=&gt; frei
			Bit 	5	=&gt; frei
			Bit 	4 - 0   =&gt; frei
			Wird ein Bit auf 1 gesetzt, geht die Leitung auf High			
        START_X2_TRIGGER:
        (nur SKMlight)  Gibt ein Triggersignal auf dem Anschluss X2 der SKMlight aus.
                        Der Trigger ist LOW-aktiv und es kann gleichzeitig nur ein 
                        einziger Trigger gestartet werden.
                        Datum DH DL W
                        DH = Trigger-Delay (High-Byte): Verzögerung in ms, bis der 
                             Trigger ausgegeben wird.
                        DL = Trigger-Delay (Low-Byte)
                        W  = Triggerbreite in ms
        STOP_SG_SEND:	Hiermit wird das SG veranlaÞt das dauernde Senden
			einzustellen.
			UnterstÏtzt bei:
				JECS
	STRTOMEM:
			Der in Daten eingetragene Datenstring wird wird direkt ins 
			shared memory geschrieben, und kann mit dem Modul p_zerlege_str
			oder Makro BLOCKINT zurückglesen werden. (fuer testzwecke).
			PARA3 muss mit C oder S,L genau bedient werden wie sonst auch.
			C= Sammeln , S oder L = ins Memory speichern.
			ACHTUNG: Voraussetzung das Makro K2000Start oder ähnliches
			   Es muss das verwendete Inteface definiert sein.
	TEST_PROKI_L:	Setzen und zurÏcksetzen der Leitungen, die fÏr Prokist
			Verwendung finden. (TP)
			DATUM: DD DD	=&gt; 16 Bit	(0000....FFFF)
			Bit	15 - 12 =&gt; Handschakeleitungen DF4-DF1 (Pin 10-13)
			Bit	11 - 8  =&gt; Resetleitungen      RS4-RS1 (Pin 6-9)
			ACHTUNG: bei folgenden Leitungen sind die auf high
			gesetzten Leitungen auf high, der Rest ist offen.
			Sind alle Bits auf 0, so werden alle Leitungen auf Low
			gesetzt.
			Bit	7	=&gt; K-Leitung
			Bit	6	=&gt; L-Leitung
			Bit 	5	=&gt; CLK-Leitung
			Bit 	4 - 0   =&gt; frei
			Wird ein Bit auf 1 gesetzt, geht die Leitung auf High			
	TIMEOUT_PSS:
			Hiermit kann der Timeout der PSS gesetzt werden.
			(Eintrag in ms, 1...640000ms)
	TIMEOUT_SKM:
			Hiermit kann der Timeout der SKM gesetzt werden.
			(Eintrag in ms, 1...640000ms)
	TRIG_SGEMPF_ON: Einschalten des Triggers bei Empfang vom SG.
			Achtung nur als Gate-Funktion zu verwenden.
			Triggerline unter DATUM eintragen:
			Triggerline durch E_TRIGGER mit E_TRG_MODE: NEW vergeben
			lassen.
			UnterstÏtzt bei SKM ab V4.90:
				KP2000
				EASY			
	TRIG_SGEMPF_OF: Abschalten des Triggers bei Empfang vom SG.
			noch nicht implementiert !!
	WEGFAHRSPERRE:	Hiermit wird die Wegfahrsperre im SG gelÎst.
			UnterstÏtzt bei:
				JECS
	WEGFAHR_LESE:	Hiermit wird die Wegfahrsperrenbyte vom SG gelesen.
			UnterstÏtzt bei:
				JECS
	WRITE_EEPROM:	Dieser Befehl beschreibt ein EEPROM mit den im String DATUM
			stehenden Daten, ab der Anfangsadresse.
			Aufbau des Datenstrings: 
				Anfangsadresse 	= 00..FF
				Datum 1		= 00..FF (highbyte)
				Datum 1		= 00..FF (lowbyte)
				Datum n		= 00..FF (highbyte)
				Datum n		= 00..FF (lowbyte)
			UnterstÏtzt bei:
				EEPROM
	WRITE_ENABLE:	Dieser Befehl schaltet das Eeprom in den Zustand, daÞ
			es beschrieben werden kann.
			UnterstÏtzt bei:
				EEPROM
	WRITE_DISABLE:	Dieser Befehl schaltet das Eeprom in den Zustand, daÞ
			das beschreiben verboten wird.
			UnterstÏtzt bei:
				EEPROM
        USS4_INIT:      Schreibt die Settings für das USS4-Protokoll zur SKMlight
                        Hierfuer muessen die Parameter jedoch zuerst mit dem 
                        Modul p_init besetzt werden. 
                        DATUM: keines
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)
        USS4_SENDING    Startet das Senden eines Ultraschall-Signals. Nach dem Senden wird 
                        ein Triggersignal ausgegeben und die S/E-Leitung wird losgelassen.
                           * DATUM: keines
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)
        USS4_RECEIVING: Startet das Empfangen eines Ultraschall-Signals, gibt ein Triggersignal 
                        aus und nimmt sich dann von der S/E-Leitung.
                        DATUM: keines
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)   
        USS4_SEND_REC:
                        Startet das Senden eines Ultraschall-Signals am Nachbarsensor.
                        Gleichzeitig startet diese Funktion das Empfangen dieses Ultraschall-
                        Signals am aktuellen Sensor. Es wird ein Triggersignal ausgegeben, sobald
                        das Senden gestartet wurde.
                        DATUM: keines
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)   
        USS4_SEND_TRIG: Wies USS4_SENDING, jedoch wird eine Zeit in ms/inc spaeter ab ende des Sendesignals
                        ein Trigger von 40 us Dauer auf der S/E-Leitung ausgegeben (Initialisierbar mit p_init).
.                       DATUM: keines
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)
        USS4_GET_STATUS:Liest den Status aus dem USS4.
                        Antwortdaten: 1 Statusbyte. Der Status des USS4 besteht aus 3 Bits 
                        (die restlichen Bits werden auf 0 gesetzt).                        
                        DATUM: keines
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)   
        USS4_WRITE_PAR:
                        Parametrisiert den USS4 mit den übergebenen Bits. Die CRC wird von 
                        automatisch berechnet und angehängt. Die CRC-Berechnung erfolgt nach dem 
                        Polynom P(x) = x^8 + x^7 + x^4 + x^3 + x + 1.
                           * DATUM: 9 Bytes (MSB zuerst). Da es nur 68 Parameterbits gibt, 
                             werden die 4 MSBits ignoriert.
                           * Antwortdaten: keine
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)  
        USS4_PROG:
                        Programmiert den USS4. Diese Programmierung dient als Abgleich.
                        * DATUM: DD SS 
                           DD = 1 Byte zu Programmierendes Datum
                           SS = Modebyte: 0 = kein Zapping
                                          sonst = Zapping
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)                         
	BEFEHLxx:	Mit diesem SchlÏsselwort kann jeder beliebige Befehl an  
			die Schnittststelle gegeben werden.
			Syntax: 
			BEFEHLXX wobei XX fÏr den Hex-Code des entsprechenden
			Befehls steht. Der Hex-Code zum jeweiligen Befehl 
			kann der Doku der Schnittstelle entnommen werden.
			Vor den Datenstring wird hier noch eine StringlÌnge
			fÏr das Protokoll.
	COMMANDxx:	Wie BEFEHLxx jedoch wird keine LÌnge vor den Daten-
			string gehÌngt.</pre><b><a name="param4">4</a> DATUM</b><pre>	Hier ist der String zur PSS bzw. zum SG einzutragen.
    			BlocklÌnge und Checksumme fÏr die jeweiligen Protokolle
			ermittelt die Software hier oder auf der PSS selbst.
			Der Header von KP2000 muÞ beim INIT mitgeteilt werden.</pre><b><a name="param5">5</a> PARA1</b><pre>	Siehe Befehl REIZ_PAV</pre><b><a name="param6">6</a> PARA2</b><pre>	Siehe Befehl REIZ_PAV
    			NOERROR&lt;fehlercode&gt; : z.B. NOERRORE3	"nur SKM"
				Bei dem hier eingetragenen Fehler-
				code wird der von der SKM zurueckgegebene Fehler
				als Messwert weitergegeben. Es wird kein 
				Fehlerflag gesetzt und keine Fehlermeldung im 
				Log-File kreiert.
				Fehlercodes sind aus der SKM-Doku zu entnehmen.</pre><b><a name="param7">7</a> PARA3</b><pre>	Steuerparameter 
    	C:		Die Strings in Datum werden so lange aneinander gehÌngt,
			bis hier ein L, S oder I eingetragen wird.
	L:		Der String in Datum wird zur PSS/SKM gesendet und es
			wird auf Antwort gewartet.
			Ist der Paramter DATUM leer, so wird nur eine Antwort
			von der SKM geholt. Diese Antwort kann durch einen 
			frueheren Befehl im Speicher der SKM hinterlegt worden sein.
             Besonderheiten:
             L_NOANSWER:Es darf keine Antwort vom SG kommen. Dann wird der Schritt gut 
                        gesetzt. Der Messwert wird auf FF00 gesetzt und kann mit 
                        BLOCKHEX ausgewertet werden. 
             L_xx:	Die Antwort des SG ist egal. Der Schritt wird auch gut gesetzt
                        wenn keine Antwort kommt. Wenn keine Antwort kommt werden die 
                        Bytes xx als Messwerte bereitgestellt und können mit BLOCKHEX 
                        ausgewertet werden.(z.B. xx=00..FF oder xx=1234)
	S:		Der String in Datum wird zur PSS/SKM gesendet, dann wird
			das Programm ohne auf Antwort zu warten fortgesetzt.
			SKM: Eine Ausnahme bildet hierfÏr der Befehl COMBLOCK.
			     Hier wird der String nur zum SG gesendet. Die
			     Antwort des SG wird ignoriert und geht verloren.
			     (Standard PAV)
        G		Es wird eine Antwort die im Speicher der Schnittstelle 
                        hinterlegt ist ausgelesen wie unter unter L.
                        ACHTUNG: Geht nicht bei COMBLOCK
	INIT:		Wie Befehl S: die Antwort wird jedoch erwartet,
			zwischengespeichert und kann spaeter mit L abgeholt
			werden. 
	F:		Wie S, jedoch wird das von der SKM gelieferte Ergebnis 
			in ein File geschrieben und auf der /tmp- Direktory 
			abgelegt. ZusÌtzlich kann das Ergebnis aber wie gehabt
			ausgewertet werden bis zu 256 Byte.</pre><b><a name="param8">8</a> PARA4</b><pre>	Steuerparameter for Future use</pre><b><a name="param9">9</a> ERGEBNIS</b><pre>		Pointer auf den Antwortstring der PSS/SKM</pre><b><a name="param10">10</a> FEHLERFLAG</b><pre>	Wird gesetzt bei aufgetretenem Fehler

   Revision 1.1  2001/12/18 10:47:33  sgc3sa
   Anpassungen fuer Linux und QT

   Revision 1.27  2001/09/24 08:07:19  ssm3bw
   ssm3bw_010924: COMBLOCK_ANW enhanced

   Revision 1.26  2001/08/16 13:02:37  ssm3bw
   SymToAddr activated again

   Revision 1.25  2001/06/19 13:30:03  lehmann
   Änderung für Linux

   Revision 1.24  2001/03/29 14:39:23  lehmann
   Eingabe und Concatinierung von langen Strings implementiert

   Revision 1.23  2001/02/09 14:27:15  PIJ3SA
   SymToAddr raus

   Revision 1.22  2000/11/27 09:29:53  keppler
   Synchronisiert mit aenderungen AnW

   Revision 1.21  2000/10/23 09:39:05  schneid
   COMBLOCK_ANW fuer SYM-Files definiert

   Revision 1.21  2000/08/16 13:56:47  keppler
   Doku geaendert

   Revision 1.20  2000/08/16 12:12:01  keppler
   Doku erweitert

   Revision 1.19  2000/01/21 13:46:22  keppler
   Doku erweitert

   Revision 1.18  2000/01/11 12:14:15  keppler
   Doku erweitert

   Revision 1.17  1999/12/22 10:05:59  keppler
   $ID -&gt; $Id

   Revision 1.16  1999/12/22 09:12:27  keppler
   $Header -&gt; $Id

   Revision 1.15  1999/10/26 15:27:34  keppler
   Defaultprozess = vxi_pss

Revision 1.14  99/10/26  15:25:16  15:25:16  wiese (Stefan Wiese)
Return -1 eingefuehrt

Revision 1.13  99/10/22  10:11:01  10:11:01  keppler (Fritz Keppler)
Errormessage und Doku

Revision 1.12  99/04/20  12:59:25  12:59:25  wiese (Stefan Wiese)
FILE_DELETE neu

Revision 1.11  99/04/20  12:54:18  12:54:18  keppler (Fritz Keppler)
SET_PROKI_L neu

Revision 1.10  99/03/10  15:04:37  15:04:37  wiese (Stefan Wiese)
Doku klarer

Revision 1.9  99/01/28  11:50:43  11:50:43  keppler (Fritz Keppler)
Doku erweitert

Revision 1.8  98/11/27  10:33:03  10:33:03  keppler (Fritz Keppler)
Doku erweitert

Revision 1.7  98/09/30  13:24:32  13:24:32  keppler (Fritz Keppler)
Doku werweitert

Revision 1.6  98/09/25  14:09:41  14:09:41  wiese (Stefan Wiese)
Doku erweitert

Revision 1.5  98/09/18  17:52:55  17:52:55  wiese (Stefan Wiese)
REIZ_PAV neu

Revision 1.4  98/09/18  17:35:23  17:35:23  keppler (Fritz Keppler)
DOKU PCC_DOWNLOAD

Revision 1.3  98/08/13  17:42:55  17:42:55  keppler (Fritz Keppler)
no entry

Revision 1.2  98/07/20  14:35:32  14:35:32  keppler (Fritz Keppler)
Modul auch im sammle Mode schrittfÌhig

Revision 1.1  98/07/02  13:59:58  13:59:58  keppler (Fritz Keppler)
Initial revision

Revision 1.12  98/05/27  17:13:14  17:13:14  keppler (Fritz Keppler)
Doku erweitert

Revision 1.11  98/05/06  07:28:25  07:28:25  keppler (Fritz Keppler)
Doku erweitert

Revision 1.10  98/04/29  16:27:24  16:27:24  wiese (Stefan Wiese)
P_AUFTRAG_B neu

Revision 1.9  98/03/03  10:36:13  10:36:13  keppler (Fritz Keppler)
Doku erweitert

Revision 1.8  98/02/25  08:47:17  08:47:17  keppler (Fritz Keppler)
Doku erweitert

Revision 1.7  98/02/13  14:01:14  14:01:14  keppler (Fritz Keppler)
Doku erweitert

Revision 1.6  98/02/09  18:03:31  18:03:31  keppler (Fritz Keppler)
Schrittbetrieb vor starten des Programms

Revision 1.5  98/01/30  15:38:54  15:38:54  keppler (Fritz Keppler)
Doku erweitert

Revision 1.4  98/01/26  16:52:34  16:52:34  keppler (Fritz Keppler)
no entry

Revision 1.3  97/12/17  10:51:31  10:51:31  keppler (Fritz Keppler)
Doku erweitert

Revision 1.2  97/12/10  13:55:00  13:55:00  keppler (Fritz Keppler)
Doku erweitert

Revision 1.1  97/12/02  14:39:59  14:39:59  keppler (Fritz Keppler)
Initial revision

Revision 1.1  96/11/29  11:22:38  11:22:38  keppler (Fritz Keppler)
Initial revision

Revision 1.6  96/07/11  09:39:18  09:39:18  gueltlin (Jochen Gueltling)
include-File STRIN_540 entfernt

Revision 1.5  96/07/04  15:31:51  15:31:51  keppler (Fritz Keppler)
Doku erweitert.

Revision 1.4  96/07/04  15:23:15  15:23:15  keppler (Fritz Keppler)
Doku erweitert.

Revision 1.3  96/06/05  13:44:57  13:44:57  keppler (Fritz Keppler)
Keine Fehler mit prolint

Revision 1.2  96/06/05  13:32:36  13:32:36  keppler (Fritz Keppler)
Erste funktionierende Version

Revision 1.1  96/05/20  14:30:18  14:30:18  keppler (Fritz Keppler)
Initial revision

   ---------------------------------------------------------------------
</PRE>
</BODY>
</HTML>
