<HTML>
<HEAD>
<TITLE>P_AUFTRAG</TITLE>
<META NAME="Generator" CONTENT="KDOC ">
</HEAD>
<BODY bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#000099" alink= "#ffffff">

<table BORDER=0 COLS=1 WIDTH="100%" BGCOLOR="#FFFFCC" NOSAVE >
<tr ALIGN=CENTER VALIGN=CENTER NOSAVE>
<td NOSAVE><font face="Arial,Helvetica"><font size=+2></font></font>
<br><font face="Arial,Helvetica"><font size=+2>CCS Modul &nbsp;&nbsp;<b>P_AUFTRAG</b></font></font>
<br>&nbsp;</td>
</tr>
</table>
<PRE>
   $Id: p_auftrag.C,v 1.48 2005/12/19 14:33:11 cvs Exp $
   ---------------------------------------------------------------------
   Kurzbeschreibung: 	Auftrag an die PSS/SKM senden.
   ---------------------------------------------------------------------
   Projekt:		CCS
   Sourcefile:		p_auftrag.C
   Autor:		RtW/TEF72-Keppler (02.04.96)
   Zielsystem:		HP9000/V743 (HP-RT 2.0x), /Sxxx (HP-UX 9.0x)
   Sprache:		C++
   ---------------------------------------------------------------------
   Prototyp:
   MPI Schnittstelle
   void p_init(shm_stringpointer *zeilen_info
	   ,shm_stringpointer    *zeilen_wert
	   ,long index1
	   ,long anzahl)
   
   ---------------------------------------------------------------------
   Aufruf: im Vectorinterpreter
   
	 (*funktionen[modulnummer])
	    (Ssp_expand_zeile
	     ,Ssp_expand_wert
	     ,p_verwaltung-&gt;begin_modulblock
	     ,p_verwaltung-&gt;anzahl_modulparameter);

   

      ---------------------------------------------------------------------
   Funktionsbeschreibung:
   Dieses Modul dient zur Auftragsvergabe an die PSS. Hiermit kŒnnen beliebige
   Strings an die PSS bzw. an das SG gesendet werden. Die Auswertung der 
   Antwort erfolgt nicht in diesem Modul. Die Antwort wird im shared Memory
   abgelegt und kann dort z.B. vom Modul p_zerlege_string geholt und 
   verarbeitet werden.
   
   Einfuehrung von langen Variablen:
   Der Befehl C ist bei diesen Variablen nicht erlaubt.
   Eine Konvertierung bei 0x findet nicht statt.
   
   Beschreibung der Modulœbergabeparameter:</pre><b><a name="param1">1</a> PRUEFSCHRITT</b><pre>
   	GAUDI Prœfschritt
   ------------------------------</pre><b><a name="param2">2</a> POSITION</b><pre>
   	PAV- Position
   ------------------------------</pre><b><a name="param3">3</a> BEFEHL</b><pre>	Steuerbefehl fœr die PSS/SKM
    			Diese Befehle gelten auch fœr die SKM falls dies 
			explizit vermerkt ist.
	ASCCAN_SWITCH:	Bei ASCCAN werden die KWP2000-Signale f¸r die K-Line einfach auf den
	(nur SKMlight)	CAN-Bus gelegt (nicht zu verwechseln mit KWP2000 over CAN). F¸r den 
			Host sieht es so aus, als w¸rde ¸ber K-Line kommuniziert werden. Der 
			Host muss lediglich vor der Kommunikation den Befehl ASCCAN_SWITCH(1) 
			und am Ende der gesamten Kommunikation wieder ASCCAN_SWITCH(0) absetzen.
			Der Befehl ASCCAN_SWITCH nimmt die hardwarem‰ﬂige Umschaltung vor.
			DATUM 0 -&gt; ASCCAN wird deaktiviert (Standard)
			DATUM 1 -&gt; ASCCAN wird aktiviert
			Es ist zu beachten, dass f¸r ASCCAN ein spezieller Adapterstecker
			notwendig ist. Solange ASCCAN aktiviert ist, kann ¸ber die normale
			CAN- und K-Line-Schnittstelle nicht kommuniziert werden!
	BEDIENBLOCK:	Der Block mit dem die Komunikation mir dem SG 
			aufrechterhalten werden soll, kann hier der PSS
			mitgeteilt werden. Dieser Befehl muﬁ nach Initialisierung
			der Schnittstelle und vor reizen des SG erfolgen.
			Unterstœtzt bei:
				KP2000
				BLOCK
        ECHOBLOCK: 	Echofunktionalit‰t auf K-Line: 
                        Stellt einen Block ein, der nach Empfang einer definierten Botschaft
                        gesendet wird.
                        Wird nicht bei Protokollen ¸ber K-Line unterst¸tzt.
                        (siehe auch ECHOVERGL_BLOCK)
        ECHOVERGL_BLOCK: Echofunktionalit‰t auf K-Line.
                        Stellt einen Block ein, auf den, die ¸ber die K-line empfangenen Daten 
                        verglichen werden. Die Echofunktionalit‰t wird aktiviert, wenn die
                        Kommandos ECHOBLOCK und ECHOVERGL_BLOCK abgesendet wurden.
                        Die Reihenfolge ist egal. Der Echoblock wird nur 1 mal abgesendet, dann
                        wird die Funktion deaktiviert und muss ggf. neu aufgesetzt werden.
                        Wird nicht bei Protokollen ¸ber K-Line unterst¸tzt.
                        (siehe auch ECHOBLOCK)                      
	BUILD_CS:	Dieser Befehl bildet eine Checksumme œber den im Parameter
			Daten angegebenen Datenbereich.
			Stringaufbau im Parameter DATUM:
				Anfangsadresse 	= 00..FF
				Endadresse 	= 00..FF
			Unterstœtzt bei:
				EEPROM
	BAUDRATE:	Fœr PSS: Dient der Umschaltung der Baudrate
			In DATUM ist "tthh" einzutragen.
			tt= tausender der Baudrate = 00..FF in Hex
			hh= hunderter der Baudrate = 00..FF in Hex
	CAN_BKGND_START:Startet im Hintergrund die Embedded CAN-Restbussimulation.
	(nur SKMlight)	Falls parallel dazu beispielsweise der "KWP2000 on CAN"-
			Tester verwendet werden soll, muss darauf geachtet werden
			dass alle CAN-Bus-Teilnehmer dieselben CAN-Bus-
			Eigenschaften einstellen.
			Modus "S" verwenden!
	CAN_BKGND_STOP:	Beendet die Embedded CAN-Restbussimulation.
	(nur SKMlight)	Modus "S" verwenden!
	CAN_BKGND_ON_KEY:‹ber diesen Befehl kann die Embedded CAN-Restbussimulation
	(nur SKMlight)	durch "Tastatur-Zeichen" manipuliert werden.
			DATUM ist 1 Byte ("Tastatur-Zeichen") als Hex-Wert.
			Beispiel: Zeichen 'a' wird mit 61 dargestellt.
			Modus "S" verwenden!
	COMBLOCK:	Komunikation mit dem SG. Es wird ein Block
			zum SG gesendet und auf die Antwort vom SG 
			gewartet. Die Antwort vom SG wird zum Host 
			weitergeleitet.
			Der zum SG zu sendende Block ist im Parameter
			DATUM einzutragen.
			Unterstœtzt bei:
				KP2000
				DDS
				JECS: PS-Befehl
				EASY
				K71
				BLOCK
    	COMBLOCK_MAD:	Wie COMBLOCK, jedoch wird nach empfang der Botschaft
			das Senden des SG gestoppt.
			Unterstœtzt bei:
				JECS: MAD-Kommando
    	DLM_NACHLADEN:	Mit diesem Befehl wird das Downloadmodul aus dem 
	(nur SKM)	pcc-File zum SG geladen.
			Unterstœtzt bei: (nur SKM)
				Prokist
    	DREZ_FUEHLER:	Mit diesem Befehl wird Frequenz fuer die Drehzahlfuehler der
			ABS-Geraete angeschaltet. 
			Eingabe in DATUM:	NN MM F1 F1 T1 T1.... F4 F4 T4 T4
			
			NN = Nummer des Drehzahlfuehler in Ascii
				31 =&gt; DF1 ...
			Prokist-Pins am 80C176-Controller Ausgaenge
			P2.3	HSK_0	CC3IO	DF1=&gt;31	DZF_VL	Pin13
			P2.4	HSK_1   CC4IO	DF2=&gt;32	DZF_HR	Pin12
			P2.5	HSK_2	CC5IO	DF3=&gt;33	DZF_VR	Pin11
			P2.6	HSK_3	CC6IO	DF4=&gt;34	DZF_HL  Pin10
			MM = Mode
				41= A=	Activate
				44= D=	Deactivate
				48= H= 	statisch high	
				4C= L= 	statisch Low
			F1F1 = Frequenz in Hz (Hex) (0000..FFFF)
			
			Bsp.: fuer DATUM
		        	31 41 03 E8  aktiviere DF1 mit 1000Hz
		        	
		     Neues Feature PWM
			NN = Mode 
				 4D= M= Activate PWM
				 44= D= Deactivate PWM
			MM = Mode 
				 45= E= Alle Ausgaenge mit dem gleichen Signal
				    F1F1 = Frequenz in Hz (Hex) (0000..FFFF)
					   fuer alle Kanaele
				    T1T1 = Tastverhaeltnis fuer alle Kanaele
				 46= F= Wie E jedoch werden die Signale
					invertiert ausgegeben.
				 44= D= Jeder Ausgang eigenes Signal
				 
			F1F1..F4F4= Frequenz in Hz (Hex) (0000..FFFF)
			T1T1..T4T4= Tastverhaeltnis (0000..FFFF)
			
			Bsp.: fuer PWM
			      4D 45 07 D0 00 03 aktiviere DF1 -DF4 mit 2000Hz
						und Tastverhaeltnis 1/3
			   
			Unterstuetzt bei: (nur SKM und SKMlight)
				alle Protokolle
                        Ausgang auf SKMlight: Buchse X5 (25polige D-sub) Pin 7
	EMPFANG_SG:	Die Schnittstelle wird auf hoeren geschaltet. Es muﬁ 
			innerhalb der Timeoutzeit eine Botschaft vom SG 
			empfangen werden, sonst erfolgt eine Fehlermeldung.
			ACHTUNG: 
			Ein schalten der Komunikationsleitung auf high wÃhrend 
			die Schnittstelle auf hoeren geschaltet ist, fœhrt zu 
			falschen (sinnlosen) empfangenen Botschaften, und ist 
			daher nicht mŒglich.
			Unterstœtzt bei:
				DDS
				EASY
				K71
	FILE_LOAD:	Syntax wie FLASH_PROG, jedoch wird das File nur bei 
			nicht vorhandensein auf die SKM geladen. Ist das File 
			schon vorhanden, dann findet keine Aktion statt.
			Unterstœtzt bei: (SKM)
				Alle Protokolle
	FILE_DELETE:	Alle Files auf der SKM//PSS werden gelŒscht. Diese Option zwingt
	                zum nachladen aller Files. !ACHTUNG! Diese Option darf nicht bei
			jedem Durchlauf stattfinden und muﬁ z.B. duch eine IF - THEN - ELSE
			Struktur abgefangen werden (nur Rœstlauf o.Ã.)
				Alle Protokolle
	FLASH_PROG:	Mit diesem Befehl kann eine Flashprogrammierung durch-
			gefœhrt werden. In der Vatiablen DATUM sind die 
			notwendigen Informationen an die PSS/SKM einzutragen.
			(Siehe auch PSS-Doku. oder SKM-Doku) Ist das zu
			programmierende File mit der Endung .bin
			der PSS/SKM nicht bekannt, so wird dies hier automatisch 
			geladen, und dann die Programmierung durchgefœhrt.
			Beispielstring in DATUM:
			AA||&lt;filename&gt;||MM||LL||OOOOOO||NNNNNN||
			
			AA      = String der vor die Daten zum SG gehÃngt wird
				  also z.B. der Blocktitel und Adressen.
			MM 	= Modus:		
			00 =&gt;	Die LÃnge LL ist die relev. DatenlÃnge fœr die BlŒcke zum SG
			01 =&gt; 	Die LÃnge zum SG steht im File
			02 =&gt; 	Es wird mit Offset und LÃnge zugegriffen
				Die LÃnge LL ist die relev. DatenlÃnge fœr die BlŒcke zum SG
			03 =&gt; 	Es wird mit Offset und LÃnge zugegriffen
				Die LÃnge zum SG steht im File
			LL	=LÃnge :		LÃnge des Blocks zum SG. (0..FF)
			Bei Modus 02 oder 03: OOOOOO und NNNNNN
			OOOOOO=Offset:	Offset mit dem auf das File zugegriffen werden soll
			NNNNNN=LÃnge: 	Zu programmierende LÃnge in Byte
			
			Unterstœtzt bei:
				Alle Protokolle
	FLASH_ANTW_EIN:	Mit diesem Befehl kann die Antwort die vom SG bei der
			Flashprogrammierung erwartet wird eingestellt werden.
			Mit setzen des Initparameters 0x80 = FLASH_SG_ANTW = 02
			wird die Antwort des SG's dann mit dieser Botschaft auf 
			€bereinstimmung verglichen (nur die Nutzdaten einschl.
			Blcktitel).
			Unterstœtzt bei: (SKM/PSS)
				Alle Protokolle 
	FLASH_PROG_PAR:	Wie FLASH_PROG, jedoch kŒnnen hier im Zusammenhang mit
			PARA3 = L mehrere PSS'n nacheinander dazu veranlaﬁt 
			werden, einen Flashdatensatz zum SG zu programmieren.
			Die Antwort OK wird zurœckgegeben befor die Flash-
			programmierung erfolgt.
			Die Antwort fœr die Richtigkeit der Programmierung 
			kann spÃter mit einem erneuten Modulaufruf 
			geholt werden, indem PARA3 = G gesetzt wird.
			Bevor eine andere PSS angesprochen wird, muﬁ zuerst die 
			Adresse mit dem Modul P_STEUER geÃndert werden.
			Unterstœtzt bei:
				Alle Protokolle
        GET_DIGITAL_IN:
        (nur SKMlight)  liest die digitalen Eing‰nge von der SKMlight zurueck (1 Byte)
                        Es stehen 5 Kan‰le zur Verf¸gung (falls nicht im gew‰hlten Protokoll
                        benoetigt.)
                        Das Ergebnis kann mit dem Modul p_zerlege_str ausgewertet werden. 
                        Die Bits 0,1 und 7 sind immer 1. Die relevanten bits liegen also
                        von Bit 2-6. 
                        Z.B.:	ERGEBNIS = 87	-&gt; IN1 auf high alle anderen auf 0 
                                ERGEBNIS = 97   -&gt; IN1 und IN3 auf high
	INIT_PROTOCOL:	Hiermit wird initialisiert, ob 	(alt: INIT_PRUEFUNG)
	(nur SKM)	E = Endprœfung 
			Z = Zwischenprœfung oder
			P = Programmierung des SG
			gewœnscht wird. Das Zeichen E/Z/P muﬁ unter Datum 
			eingetragen werden.
			Unterstœtzt bei: (nur SKM)
				Prokist 
	KOMM_ENDE:	Hiermit beendet die Schnittstelle die Kommunikation mit 
			dem SG. D.h., daﬁ eine Bedienung der Schnittstelle nicht 
			mehr erfolgt. 
			Wird dieser Befehl vor Abschalten des SG nicht an die 
			Schnittstelle gegeben, so wird ein Timeout abgewarte, 
			und die Prœfung verzŒgert sich entsprechend.
			Unterstœtzt bei:
				Alle Protokolle
	LOESCHE:	Wie Befehl COMBLOCK, jedoch wird der Befehl nur unter 
			folgenden Bedingungen ausgefœhrt.
			1. Der Standtyp muﬁ HT sein.
			2. Die Pruefung muﬁ bis hier Fehlerfrei gelaufen sein.
			3. Es muﬁ die letzte Wiederholpruefung sein.
			Unterstœtzt bei: (SKM und PSS)
				Alle Protokolle	
                                
        MERKE:		Die jetzt bei Parameter DATUM eingetragenen Daten 
                        werden gespeichert.Und bei Befehl REIZ_PAV mit PARA01 =10
                        verwendet. 
                        Notwendig f¸r Workarround Reizen des NEC mit Makro K2000INI
                        synchronem Protokoll. 
	MELEXIS_CLK_SWITCH:
	(nur SKMlight)	Es gibt F‰lle, in denen nach Absetzen spezieller Melexisbefehle die
			Taktausgabe ausgeschalten wird. ‹ber MELEXIS_CLK_SWITCH kann die
			Taktausgabe wieder gestartet werden.
			DATUM (1 Byte): 01 =&gt; Taktausgabe wird gestartet
			                00 =&gt; Taktausgabe wird ausgeschalten
	PAS4_INIT:	Schreibt die Settings (Parameter), die f¸r die PAS4-Kommunikation
	(nur SKMlight)	verwendet werden. Hierfuer muessen die Parameter jedoch zuerst mit
			dem Modul p_init besetzt werden.
			DATUM: keines
	PAS4_COMMAND:	Sendet den ¸bergebenen PAS4-Befehl an den PAS4-Sensor.
	(nur SKMlight)	DATUM: Byte 1: Bit0 = A4, Bit1-3 = I0-I2, Bit4-7 werden ignoriert
			       Byte 2: Bit0-3 = D0-D3, Bit4-7 = A0-A3
	PAS4_PROGRAMMING:
	(nur SKMlight)	Erlaubt das Programmieren/Brennen von bis zu 20 Bits im PROM des
			PAS4-Sensors. Dabei kann das Datum von PAS4_COMMAND bis zu 5 mal direkt
			hintereinander liegend angegeben werden. Folgende Besonderheiten sind
			zu beachten:
			a) Bei den Daten (D0-D3) kˆnnen jeweils mehrere Datenbits gesetzt sein.
			b) Wird das Datum mehrmals angegeben, dann m¸ssen die Instructionsbits
			   (I0-I2) jeweils gleich sein.
			Dieser Befehl kehrt bereits zur¸ck, BEVOR er vollst‰ndig abgearbeitet
			wurde!
			DATUM: Byte 1: Bit0 = A4, Bit1-3 = I0-I2, Bit4-7 werden ignoriert
			       Byte 2: Bit0-3 = D0-D3, Bit4-7 = A0-A3
			       Byte 1 und 2 kˆnnen bis zu 5 mal angegeben werden (max. 5*2 Bytes).
	PAS4_READING:	Initiiert das Lesen von bis zu 64 Bits aus dem PAS4-Sensor. Die Anfangs-
	(nur SKMlight)	und Endadresse wird angegeben und f¸r jede Adresse werden 4 Datenbits
			ausgelesen. Die Antwortdaten selbst werden von der SKMlight nicht 
			ausgewertet. Dieser Befehl kehrt bereits zur¸ck, BEVOR er vollst‰ndig
			abgearbeitet wurde!
			DATUM: Byte 1: Bit0 = A4, Bit1-3 = I0-I2, Bit4-7 werden ignoriert
			       Byte 2: Bit0-3 = D0-D3, Bit4-7 = A0-A3
			       Byte 3: Bit0-4 = A0-A4 (Endadresse)
			In Byte 1-2 ist die Startadresse und in Byte 3 die Endadresse enthalten.
			Die Datenbits aus Byte 1 werden z.Zt. nicht verwendet und sollten auf  
			0001 gesetzt sein.
	PAS4_SET_I0_1_2:Hiermit kˆnnen die Ausg‰nge I0, I1 und I2 (Instruction) beliebig gesetzt
	(nur SKMlight)	werden.
			DATUM: Byte 1: Bit0-3 = I0-I2, Bit4-7 werden ignoriert
	PCC_DOWNLOAD:   Wie FLASH_LOAD, jedoch wird die TTNr. nicht automatisch 
	(nur SKM)	an den Pfad angehaengt.
			Die PCC-Files muessen somit unter /hw/pcc/ stehen.
			Sollten hier Subdirectories verwendet werden, so muessen
			diese dem Filenamen vorangestellt werden.
			/hw/pcc/&lt;Subdir&gt;/&lt;Subdir&gt;/&lt;filename&gt;
	PCC_LOAD:	Wie FILE_LOAD, jedoch wird die TTNr. nicht automatisch 
	(nur SKM)	an den Pfad angehaengt.
			Die PCC-Files muessen somit unter /hw/pcc/ stehen.
			Sollten hier Subdirectories verwendet werden, so muessen
			diese dem Filenamen vorangestellt werden.
			/hw/pcc/&lt;Subdir&gt;/&lt;Subdir&gt;/&lt;filename&gt;
        PPS_COM_SPI:	Es werden ueber die SPI daten gesendet oder gelesen. 
        (nur SKMlight)  Die Daten werden immer 16 Bit weise gesendet. 
                        Es kˆnnen max. 16 * 2 Bytes gesendet/gelesen werden. Es ist 
                        nur eine geradzahlige Menge von Bytes zugelassen. (2..4 ..6.....32)
        PPS_COLLECT_DATA:
        (nur SKMlight)  Dieser Befehl gibt ein Triggersignal auf dem Output Port 2 aus, wartet die 
                        eingetragene Zeit in ms ab, und beginnt mit dem einlesen der gewuenschten
                        Anzahl von Druckwerten aus den angegebenen Kanaelen.
                        Wartezeit nach Trigger bis lesen in ms
                        Kanalwahl: bis zu 3 Kan‰le die der ASIC cg974 beherrscht.
                        Anzahl der gelesenen Druckwerte.
                        Dies Parameter bitte mit p_init initialisieren.
        PPS_COLLECT_DATA_ALL:
                        wie PPS_COLLECT_DATA jedoch werden nicht nur Druckwerte, sondern alle Werte gesammelt.
        PPS_COLLECT_DATA_REL:                
                        wie PPS_COLLECT_DATA jedoch werden nur relative Druckwerte gesammelt. Die absoluten
                        Druckwerte werden verworfen.
        PPS_COLLECT_DATA_RAW:                
                        wie PPS_COLLECT_DATA jedoch alle Werte gesammelt. Es werden keine Werte verworfen, auch nicht
                        die oversampelten.
        PPS_SENSOR_ON_COLLECT_DATA:
        PPS_SENSOR_ON_COLLECT_DATA_ALL:
        PPS_SENSOR_ON_COLLECT_DATA_REL:
        PPS_SENSOR_ON_COLLECT_DATA_RAW:
        (nur SKMlight)  Diese Befehle sind identisch zu ihrem jeweiligen Pendant (s.o.) mit dem Unterschied,
                        dass zuerst der Sensor eingeschalten wird.
        PPS_GET_COLLECTED_DATA:
        (nur SKMlight)  Diese Befehl liest die bei dem Befehl PPS_COLLECT_DATA erhaltenen daten
                        aus der SKMlight sortiert nach Kanal aus.
                        DATUM: Kanalwahl: 1 Byte:  01 = Kanal 1   (nur 1 Kanal moeglich)
                                                   02 = Kanal 2
                                                   04 = Kanal 3
                               Blockwahl  1 Byte   0...4   Da bis zu 5000 Daten pro Kanal moglich sind muessen
                                                           dies in Blˆcken zu je 1000 von der SKMlight geholt 
                                                           werden. 0=1..1000
                                                                   1=1001-2000
                                                                   2=2001-3000 etc.
                        Beispiel: Kanal 2 u. Datum 1001-2000:  DATUM = 0201
        PPS_GET_STATUS: Liest die Statusinformationen die der Sensor in der Initialisierungsphase
        (nur SKMlight)  sendet aus.
                        Hierzu muss der Befehl vor oder waehrend der Initphase abgesetz werden. 
                        ACHTUNG: Es wird maximal 250 ms auf die ID's gepollt.
                        DATUM: Kanalwahl: 1 Byte:  01 = Kanal 1  (nur 1 Kanal moeglich)
                                                   02 = Kanal 2
                                                   04 = Kanal 3
                        Es werden die Statusinfos zur¸ck gegeben (8 Byte)
        PPS_GET_STATUS_EXACTLY:
                        Wie PPS_GET_STATUS, jedoch muessen von der 16-fachen Wiederholung der Daten mindestens
                        15 Datenwerte richtig erkannt werden. Ansonsten wird eine Fehlermeldung zur¸ck gegeben.
        PPS_GET_STATUS_VERY_EXACTLY:
                        Wie PPS_GET_STATUS, jedoch muessen von der 16-fachen Wiederholung der Daten alle
                        16 Datenwerte richtig erkannt werden. Ansonsten wird eine Fehlermeldung zur¸ck gegeben.
        PPS_GET_ABS_PRESSURE:
        (nur SKMlight)  Liest die absoluten Druckwerte P1 und P2 mit ID's aus dem 
                        PPS1-Sensor aus. Hierzu wird maximal 300 ms auf die ID's gepollt, dann
                        wird die Aufgabe abgebrochen. 
                        DATUM: Kanalwahl: 1 Byte:  01 = Kanal 1   (nur 1 Kanal moeglich)
                                                   02 = Kanal 2
                                                   04 = Kanal 3
                        Antwortdaten: PPS-ID1, P1, PPS-ID2, P2  (8 Bytes)                       
        PPS_SENSOR_ON_GET_STATUS:
        (nur SKMlight)  Schaltet den PPS1-Sensor an und liest anschlieﬂend die Statusinformationen (siehe
                        PPS_GET_STATUS_EXACTLY), die der Sensor in der Initialisierungsphase sendet. 
                        DATUM: Kanalwahl: 1 Byte:  01 = Kanal 1  (nur 1 Kanal moeglich)
                                                   02 = Kanal 2
                                                   04 = Kanal 3
                        Es werden die Statusinfos zur¸ck gegeben (8 Byte)
        PPS_SENSOR_ON_GET_STATUS_PRESSURE:
        (nur SKMlight)  Schaltet den PPS1-Sensor an und liest anschlieﬂend die Statusinformationen (siehe
                        PPS_GET_STATUS_EXACTLY) und den Absolutdruck (siehe PPS_GET_ABS_PRESSURE).
                        DATUM: Kanalwahl: 1 Byte:  01 = Kanal 1  (nur 1 Kanal moeglich)
                                                   02 = Kanal 2
                                                   04 = Kanal 3
                        Es werden die Statusinfos und die Druckwerte mit IDs (PPS-ID1, P1, PPS-ID2, P2) 
                        zur¸ck gegeben - insgesamt 8 + 8 Bytes.
	PROG_SPANNUNG:	Hiermit kann die von der SKM  erzeugte Programmierspannung
			eingestellt werden.
			Eintrag in DATUM: &lt;Spannung in mV&gt;\\&lt;Mode&gt;
				Z.B.	   3200\\00 =&gt; 3,2 V mit Mode = 0
				Mode: 00 = Interne Reverenz, Prog.Spannung geschaltet
				Mode: 01 = Externe Referenz,Prog.Spannung geschaltet
				Mode: 02 = Ausgangsrelais wird geoeffnet
	PRUEFMODUL:	Mit diesem Befehl wird die SKM veranlasst eine Pruef-
	(nur SKM)		sequenz aus dem pms-File abzuarbeiten.
			Das entsprechende Label muss im Parameter DATUM angegeben
			werden. (Z.B. LABEL_55)
			Dieses Label muﬁ selbstverstÃndlich im pms-File 
			wiederzufinden sein.
			Unterstœtz bei: (nur SKM)
				Prokist
	PWM_START:	Startet die Pulsweitenmodulation mit folgenden Daten
	(nur SKM_LIGHT)	Eintrag in DATUM
			Frequenz: 	4Byte in Hex (10000Hz =&gt; 00 00 27 10)
			Highfase in %:	1Byte in Hex (75% =&gt; 4B)
			Obiges Eingabebeispiel in DATUM :  000027104B
			Es werden also immer 5 Byte erwartet. 
	PWM_STOP 	Stoppt die PWM
	(nur SKM_LIGHT) DATUM: kein Eintrag
	
	READ_EEPROM:	Dieser Befehl liest aus einem EEPROM die Daten eines
			Adressbereiches von Anfangsadresse bis Endadresse aus.
			Aufbau des Datenstrings: 
				Anfangsadresse 	= 00..FF
				Endadresse 	= 00..FF
			Unterstœtzt bei:
				EEPROM (PSS)
	REIZEN: 	Reizen des SG.
			Unterstœtzt bei:
				KP2000: (5-Baud Reizung)
				JECS
	REIZ_MA:	Reizen des SG mit Massetastung.
			Nach Massetastung meldet sich das SG. Die PSS empfÃngt 
			die Meldung, und gibt an den Host ein OK zurœck.
			Unterstœtzt bei:
				KP2000
				DDS
				K71
	REIZ_MA_E3:	Reizen des SG mit Massetastung.
			Nach Massetastung meldet sich das SG. Die PSS/SKM empfÃngt 
			die Meldung, und gibt sie an den Host weiter.
			Bei Fehler SG_ANTWORTET_NICHT wird als Status OK zurœck
			gegeben.
			Als Daten wird E3E3E3 an den Host zurœck gegeben.
			Unterstœtzt bei:
				KP2000
	REIZ_PO:	Reizen des SG durch Power On (einschalten UBATT).
			Die Schnittstelle empfÃngt die Meldung.
			Daraufhin kann mit normaler Kommunkation weiter gemacht werden.
	REIZ_PO_KEY:	Reizen des SG durch Power On (einschalten UBATT).
			Nach Power On meldet sich das SG mit den Key Bytes. 
			Die Schnittstelle empfÃngt die Meldung, und den darauf folgenden
			Acknowledge Block und gibt dann dem Host ein OK zurœck.
			Unterstœtzt bei:
				K71
				KP2000(SKM)
	REIZ_PAV:	PARA01:0 -&gt; Keine Reizung
			       1 -&gt; 5 Baud Reizung
			       2 -&gt; Massetastung
                              10 -&gt; Protokolleinstieg in NEC-Prozessor KP2000 synchron 
                                    zuvor muss Modulaufruf p_auftrag mit Befehl MERKE erfolgen.
                                    hier bei Daten &lt;reset command&gt; und &lt;bootstrap command&gt; 
                                    eingeben.
                              11 -&gt; Handshake f¸r synchrones KP2000 einschalten.
                              
			PARA02:0 -&gt; keine Reizung -&gt; Keine Funktion des Moduls
			Daraufhin kann mit normaler Kommunkation weiter gemacht werden.
	RELAIS_CLOSE:   Die bei der Initialisierung eingeschalteten Relais kŒnnen
			hier nach einem RELAIS_OPEN wieder geschlossen werden.
			Unterstœtzt bei:
				Alle Protokolle
	RELAIS_OPEN:    Die bei der Initialisierung eingeschalteten Relais kŒnnen
			hier geŒffnet werden.
			Unterstœtzt bei:
				Alle Protokolle
        REQUEST_TRIGGER:
                        Einschalten eines Triggers:Der Trigger kommt, w‰hrend eine Botschaft 
                        zum ECU gesendet wird. 
                        SKMlight-&gt;Buchse X5-&gt;Pin 21
                        DATUM: =00 -&gt; kein Trigger (Trigger ausschalten)
                               =01 -&gt; Trigger einschalten
                        Unterst¸tzt bei:
                           (derzeit nur KWP2000 ¸ber CAN bei SKMlight)
	RESET:		Es wird ein Reset auf die Schnittstellenkarte ausgegeben.
				Alle Protokolle  
	RESETTEST:	Resettest fœr das DDS-SG.
			Es wird eine Botschaft zum SG gesendet, und es darf 
			keine Antwort zurœckkommen. Dann ist dieser Test OK.
			Unterstœtzt bei:
				DDS
	RETURN:		Rœcksprung aus Protokoll ohne die Initialisierungs-
			parameter zu Ãndern.			
			Unterstœtzt bei:	(nur SKM)
				Alle Protokolle
	SAFE_STATE:	Prokist-Pins in den Anfangszustand setzen. 			
			Unterstœtzt bei:	(nur SKM)
				Prokist
	SEED_KEY:   	Seed and Key Verfahren fœr EDC 15 C. Es werden hierbei 2
			Kommunikationen mit dem SG aufgenommen, die im 
			DATUM eingetragen werden mœssen.
			B1B1B1B1...||MM||B2B2BK0K1K2K3B2B2....||
			B1 = Botschaft 1 
			B2 = Botschaft 2
			K0 - Kn = Platzhalter fœr Key
			MM = Mode : 02 = EDC15 C (access - Mode aus Botschaft B1)
			03 =  (access - Mode aus INIT-feld 0xE0)
			Unterstœtzt bei:	(nur PSS)
			Alle Protokolle
	SENDBLOCK:	Siehe SEND_SG (unten):
			Unterstuetzt bei: 	( SKM)
			alle Protokolle (ohne NOP)
	SEND_SG:	Die eingegebene Botschaft wird an das SG gesendet. Es
			wird nicht auf eine Antwort gewartet. Die Schnittstelle
			liefert sofort ein OK zurœck.
			Eine eventuelle Antwort vom SG geht verloren.
			Unterstœtzt bei: (nur PSS)
				K71
				BLOCK
        SET_DIGITAL_OUT:
        (nur SKMlight)  Setzt die digitalen Ausg‰nge auf den mitgegebenen Wert (1 Byte)
                        Es stehen 6 Kan‰le zur Verf¸gung (falls nicht im gew‰hlten Protokoll
                        benoetigt.
                        Z.B.:	DATUM = 05	-&gt; OUT 0 und OUT 2 auf high
                        ACHTUNG: 
                        Dies sollte mit der Funktion e_bits realisiert werden.
                        Diese Funktion ist nur fuer Testzwecke. 
	SET_PROKI_L:	Setzen und zuruecksetzen der Leitungen, die fœr Prokist
			Verwendung finden. (TP)
			DATUM: DD DD	=&gt; 16 Bit	(0000....FFFF)
			Bit	15 - 12 =&gt; Handschakeleitungen DF4-DF1 (Pin 10-13)
			Bit	11 - 8  =&gt; Resetleitungen      RS4-RS1 (Pin 6-9)
			Bit	7	=&gt; frei
			Bit	6	=&gt; frei
			Bit 	5	=&gt; frei
			Bit 	4 - 0   =&gt; frei
			Wird ein Bit auf 1 gesetzt, geht die Leitung auf High			
        START_X2_TRIGGER:
        (nur SKMlight)  Gibt ein Triggersignal auf dem Anschluss X2 der SKMlight aus.
                        Der Trigger ist LOW-aktiv und es kann gleichzeitig nur ein 
                        einziger Trigger gestartet werden.
                        Datum DH DL W
                        DH = Trigger-Delay (High-Byte): Verzˆgerung in ms, bis der 
                             Trigger ausgegeben wird.
                        DL = Trigger-Delay (Low-Byte)
                        W  = Triggerbreite in ms
        STOP_SG_SEND:	Hiermit wird das SG veranlaﬁt das dauernde Senden
			einzustellen.
			Unterstœtzt bei:
				JECS
	STRTOMEM:
			Der in Daten eingetragene Datenstring wird wird direkt ins 
			shared memory geschrieben, und kann mit dem Modul p_zerlege_str
			oder Makro BLOCKINT zur¸ckglesen werden. (fuer testzwecke).
			PARA3 muss mit C oder S,L genau bedient werden wie sonst auch.
			C= Sammeln , S oder L = ins Memory speichern.
			ACHTUNG: Voraussetzung das Makro K2000Start oder ‰hnliches
			   Es muss das verwendete Inteface definiert sein.
	TEST_PROKI_L:	Setzen und zurœcksetzen der Leitungen, die fœr Prokist
			Verwendung finden. (TP)
			DATUM: DD DD	=&gt; 16 Bit	(0000....FFFF)
			Bit	15 - 12 =&gt; Handschakeleitungen DF4-DF1 (Pin 10-13)
			Bit	11 - 8  =&gt; Resetleitungen      RS4-RS1 (Pin 6-9)
			ACHTUNG: bei folgenden Leitungen sind die auf high
			gesetzten Leitungen auf high, der Rest ist offen.
			Sind alle Bits auf 0, so werden alle Leitungen auf Low
			gesetzt.
			Bit	7	=&gt; K-Leitung
			Bit	6	=&gt; L-Leitung
			Bit 	5	=&gt; CLK-Leitung
			Bit 	4 - 0   =&gt; frei
			Wird ein Bit auf 1 gesetzt, geht die Leitung auf High			
	TIMEOUT_PSS:
			Hiermit kann der Timeout der PSS gesetzt werden.
			(Eintrag in ms, 1...640000ms)
	TIMEOUT_SKM:
			Hiermit kann der Timeout der SKM gesetzt werden.
			(Eintrag in ms, 1...640000ms)
	TRIG_SGEMPF_ON: Einschalten des Triggers bei Empfang vom SG.
			Achtung nur als Gate-Funktion zu verwenden.
			Triggerline unter DATUM eintragen:
			Triggerline durch E_TRIGGER mit E_TRG_MODE: NEW vergeben
			lassen.
			Unterstœtzt bei SKM ab V4.90:
				KP2000
				EASY			
	TRIG_SGEMPF_OF: Abschalten des Triggers bei Empfang vom SG.
			noch nicht implementiert !!
	WEGFAHRSPERRE:	Hiermit wird die Wegfahrsperre im SG gelŒst.
			Unterstœtzt bei:
				JECS
	WEGFAHR_LESE:	Hiermit wird die Wegfahrsperrenbyte vom SG gelesen.
			Unterstœtzt bei:
				JECS
	WRITE_EEPROM:	Dieser Befehl beschreibt ein EEPROM mit den im String DATUM
			stehenden Daten, ab der Anfangsadresse.
			Aufbau des Datenstrings: 
				Anfangsadresse 	= 00..FF
				Datum 1		= 00..FF (highbyte)
				Datum 1		= 00..FF (lowbyte)
				Datum n		= 00..FF (highbyte)
				Datum n		= 00..FF (lowbyte)
			Unterstœtzt bei:
				EEPROM
	WRITE_ENABLE:	Dieser Befehl schaltet das Eeprom in den Zustand, daﬁ
			es beschrieben werden kann.
			Unterstœtzt bei:
				EEPROM
	WRITE_DISABLE:	Dieser Befehl schaltet das Eeprom in den Zustand, daﬁ
			das beschreiben verboten wird.
			Unterstœtzt bei:
				EEPROM
        USS4_INIT:      Schreibt die Settings f¸r das USS4-Protokoll zur SKMlight
                        Hierfuer muessen die Parameter jedoch zuerst mit dem 
                        Modul p_init besetzt werden. 
                        DATUM: keines
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)
        USS4_SENDING    Startet das Senden eines Ultraschall-Signals. Nach dem Senden wird 
                        ein Triggersignal ausgegeben und die S/E-Leitung wird losgelassen.
                           * DATUM: keines
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)
        USS4_RECEIVING: Startet das Empfangen eines Ultraschall-Signals, gibt ein Triggersignal 
                        aus und nimmt sich dann von der S/E-Leitung.
                        DATUM: keines
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)   
        USS4_SEND_REC:
                        Startet das Senden eines Ultraschall-Signals am Nachbarsensor.
                        Gleichzeitig startet diese Funktion das Empfangen dieses Ultraschall-
                        Signals am aktuellen Sensor. Es wird ein Triggersignal ausgegeben, sobald
                        das Senden gestartet wurde.
                        DATUM: keines
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)   
        USS4_SEND_TRIG: Wies USS4_SENDING, jedoch wird eine Zeit in ms/inc spaeter ab ende des Sendesignals
                        ein Trigger von 40 us Dauer auf der S/E-Leitung ausgegeben (Initialisierbar mit p_init).
.                       DATUM: keines
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)
        USS4_GET_STATUS:Liest den Status aus dem USS4.
                        Antwortdaten: 1 Statusbyte. Der Status des USS4 besteht aus 3 Bits 
                        (die restlichen Bits werden auf 0 gesetzt).                        
                        DATUM: keines
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)   
        USS4_WRITE_PAR:
                        Parametrisiert den USS4 mit den ¸bergebenen Bits. Die CRC wird von 
                        automatisch berechnet und angeh‰ngt. Die CRC-Berechnung erfolgt nach dem 
                        Polynom P(x) = x^8 + x^7 + x^4 + x^3 + x + 1.
                           * DATUM: 9 Bytes (MSB zuerst). Da es nur 68 Parameterbits gibt, 
                             werden die 4 MSBits ignoriert.
                           * Antwortdaten: keine
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)  
        USS4_PROG:
                        Programmiert den USS4. Diese Programmierung dient als Abgleich.
                        * DATUM: DD SS 
                           DD = 1 Byte zu Programmierendes Datum
                           SS = Modebyte: 0 = kein Zapping
                                          sonst = Zapping
                        Unterstuetzt bei:
                           USS4-Protokoll (nur SKMlight)                         
	BEFEHLxx:	Mit diesem Schlœsselwort kann jeder beliebige Befehl an  
			die Schnittststelle gegeben werden.
			Syntax: 
			BEFEHLXX wobei XX fœr den Hex-Code des entsprechenden
			Befehls steht. Der Hex-Code zum jeweiligen Befehl 
			kann der Doku der Schnittstelle entnommen werden.
			Vor den Datenstring wird hier noch eine StringlÃnge
			fœr das Protokoll.
	COMMANDxx:	Wie BEFEHLxx jedoch wird keine LÃnge vor den Daten-
			string gehÃngt.</pre><b><a name="param4">4</a> DATUM</b><pre>	Hier ist der String zur PSS bzw. zum SG einzutragen.
    			BlocklÃnge und Checksumme fœr die jeweiligen Protokolle
			ermittelt die Software hier oder auf der PSS selbst.
			Der Header von KP2000 muﬁ beim INIT mitgeteilt werden.</pre><b><a name="param5">5</a> PARA1</b><pre>	Siehe Befehl REIZ_PAV</pre><b><a name="param6">6</a> PARA2</b><pre>	Siehe Befehl REIZ_PAV
    			NOERROR&lt;fehlercode&gt; : z.B. NOERRORE3	"nur SKM"
				Bei dem hier eingetragenen Fehler-
				code wird der von der SKM zurueckgegebene Fehler
				als Messwert weitergegeben. Es wird kein 
				Fehlerflag gesetzt und keine Fehlermeldung im 
				Log-File kreiert.
				Fehlercodes sind aus der SKM-Doku zu entnehmen.</pre><b><a name="param7">7</a> PARA3</b><pre>	Steuerparameter 
    	C:		Die Strings in Datum werden so lange aneinander gehÃngt,
			bis hier ein L, S oder I eingetragen wird.
	L:		Der String in Datum wird zur PSS/SKM gesendet und es
			wird auf Antwort gewartet.
			Ist der Paramter DATUM leer, so wird nur eine Antwort
			von der SKM geholt. Diese Antwort kann durch einen 
			frueheren Befehl im Speicher der SKM hinterlegt worden sein.
             Besonderheiten:
             L_NOANSWER:Es darf keine Antwort vom SG kommen. Dann wird der Schritt gut 
                        gesetzt. Der Messwert wird auf FF00 gesetzt und kann mit 
                        BLOCKHEX ausgewertet werden. 
             L_xx:	Die Antwort des SG ist egal. Der Schritt wird auch gut gesetzt
                        wenn keine Antwort kommt. Wenn keine Antwort kommt werden die 
                        Bytes xx als Messwerte bereitgestellt und kˆnnen mit BLOCKHEX 
                        ausgewertet werden.(z.B. xx=00..FF oder xx=1234)
	S:		Der String in Datum wird zur PSS/SKM gesendet, dann wird
			das Programm ohne auf Antwort zu warten fortgesetzt.
			SKM: Eine Ausnahme bildet hierfœr der Befehl COMBLOCK.
			     Hier wird der String nur zum SG gesendet. Die
			     Antwort des SG wird ignoriert und geht verloren.
			     (Standard PAV)
        G		Es wird eine Antwort die im Speicher der Schnittstelle 
                        hinterlegt ist ausgelesen wie unter unter L.
                        ACHTUNG: Geht nicht bei COMBLOCK
	INIT:		Wie Befehl S: die Antwort wird jedoch erwartet,
			zwischengespeichert und kann spaeter mit L abgeholt
			werden. 
	F:		Wie S, jedoch wird das von der SKM gelieferte Ergebnis 
			in ein File geschrieben und auf der /tmp- Direktory 
			abgelegt. ZusÃtzlich kann das Ergebnis aber wie gehabt
			ausgewertet werden bis zu 256 Byte.</pre><b><a name="param8">8</a> PARA4</b><pre>	Steuerparameter for Future use</pre><b><a name="param9">9</a> ERGEBNIS</b><pre>		Pointer auf den Antwortstring der PSS/SKM</pre><b><a name="param10">10</a> FEHLERFLAG</b><pre>	Wird gesetzt bei aufgetretenem Fehler

   Revision 1.1  2001/12/18 10:47:33  sgc3sa
   Anpassungen fuer Linux und QT

   Revision 1.27  2001/09/24 08:07:19  ssm3bw
   ssm3bw_010924: COMBLOCK_ANW enhanced

   Revision 1.26  2001/08/16 13:02:37  ssm3bw
   SymToAddr activated again

   Revision 1.25  2001/06/19 13:30:03  lehmann
   ƒnderung f¸r Linux

   Revision 1.24  2001/03/29 14:39:23  lehmann
   Eingabe und Concatinierung von langen Strings implementiert

   Revision 1.23  2001/02/09 14:27:15  PIJ3SA
   SymToAddr raus

   Revision 1.22  2000/11/27 09:29:53  keppler
   Synchronisiert mit aenderungen AnW

   Revision 1.21  2000/10/23 09:39:05  schneid
   COMBLOCK_ANW fuer SYM-Files definiert

   Revision 1.21  2000/08/16 13:56:47  keppler
   Doku geaendert

   Revision 1.20  2000/08/16 12:12:01  keppler
   Doku erweitert

   Revision 1.19  2000/01/21 13:46:22  keppler
   Doku erweitert

   Revision 1.18  2000/01/11 12:14:15  keppler
   Doku erweitert

   Revision 1.17  1999/12/22 10:05:59  keppler
   $ID -&gt; $Id

   Revision 1.16  1999/12/22 09:12:27  keppler
   $Header -&gt; $Id

   Revision 1.15  1999/10/26 15:27:34  keppler
   Defaultprozess = vxi_pss

Revision 1.14  99/10/26  15:25:16  15:25:16  wiese (Stefan Wiese)
Return -1 eingefuehrt

Revision 1.13  99/10/22  10:11:01  10:11:01  keppler (Fritz Keppler)
Errormessage und Doku

Revision 1.12  99/04/20  12:59:25  12:59:25  wiese (Stefan Wiese)
FILE_DELETE neu

Revision 1.11  99/04/20  12:54:18  12:54:18  keppler (Fritz Keppler)
SET_PROKI_L neu

Revision 1.10  99/03/10  15:04:37  15:04:37  wiese (Stefan Wiese)
Doku klarer

Revision 1.9  99/01/28  11:50:43  11:50:43  keppler (Fritz Keppler)
Doku erweitert

Revision 1.8  98/11/27  10:33:03  10:33:03  keppler (Fritz Keppler)
Doku erweitert

Revision 1.7  98/09/30  13:24:32  13:24:32  keppler (Fritz Keppler)
Doku werweitert

Revision 1.6  98/09/25  14:09:41  14:09:41  wiese (Stefan Wiese)
Doku erweitert

Revision 1.5  98/09/18  17:52:55  17:52:55  wiese (Stefan Wiese)
REIZ_PAV neu

Revision 1.4  98/09/18  17:35:23  17:35:23  keppler (Fritz Keppler)
DOKU PCC_DOWNLOAD

Revision 1.3  98/08/13  17:42:55  17:42:55  keppler (Fritz Keppler)
no entry

Revision 1.2  98/07/20  14:35:32  14:35:32  keppler (Fritz Keppler)
Modul auch im sammle Mode schrittfÃhig

Revision 1.1  98/07/02  13:59:58  13:59:58  keppler (Fritz Keppler)
Initial revision

Revision 1.12  98/05/27  17:13:14  17:13:14  keppler (Fritz Keppler)
Doku erweitert

Revision 1.11  98/05/06  07:28:25  07:28:25  keppler (Fritz Keppler)
Doku erweitert

Revision 1.10  98/04/29  16:27:24  16:27:24  wiese (Stefan Wiese)
P_AUFTRAG_B neu

Revision 1.9  98/03/03  10:36:13  10:36:13  keppler (Fritz Keppler)
Doku erweitert

Revision 1.8  98/02/25  08:47:17  08:47:17  keppler (Fritz Keppler)
Doku erweitert

Revision 1.7  98/02/13  14:01:14  14:01:14  keppler (Fritz Keppler)
Doku erweitert

Revision 1.6  98/02/09  18:03:31  18:03:31  keppler (Fritz Keppler)
Schrittbetrieb vor starten des Programms

Revision 1.5  98/01/30  15:38:54  15:38:54  keppler (Fritz Keppler)
Doku erweitert

Revision 1.4  98/01/26  16:52:34  16:52:34  keppler (Fritz Keppler)
no entry

Revision 1.3  97/12/17  10:51:31  10:51:31  keppler (Fritz Keppler)
Doku erweitert

Revision 1.2  97/12/10  13:55:00  13:55:00  keppler (Fritz Keppler)
Doku erweitert

Revision 1.1  97/12/02  14:39:59  14:39:59  keppler (Fritz Keppler)
Initial revision

Revision 1.1  96/11/29  11:22:38  11:22:38  keppler (Fritz Keppler)
Initial revision

Revision 1.6  96/07/11  09:39:18  09:39:18  gueltlin (Jochen Gueltling)
include-File STRIN_540 entfernt

Revision 1.5  96/07/04  15:31:51  15:31:51  keppler (Fritz Keppler)
Doku erweitert.

Revision 1.4  96/07/04  15:23:15  15:23:15  keppler (Fritz Keppler)
Doku erweitert.

Revision 1.3  96/06/05  13:44:57  13:44:57  keppler (Fritz Keppler)
Keine Fehler mit prolint

Revision 1.2  96/06/05  13:32:36  13:32:36  keppler (Fritz Keppler)
Erste funktionierende Version

Revision 1.1  96/05/20  14:30:18  14:30:18  keppler (Fritz Keppler)
Initial revision

   ---------------------------------------------------------------------
</PRE>
</BODY>
</HTML>
